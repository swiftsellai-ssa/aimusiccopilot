<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Music Co-pilot - Evolution v5.4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .audio-init-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .audio-init-content {
            text-align: center;
            padding: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 500px;
        }

        .audio-init-btn {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            border: none;
            color: #000;
            padding: 20px 40px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .audio-init-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0,255,136,0.5);
        }

        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar terminal controls"
                "sidebar terminal controls";
            grid-template-columns: 280px 1fr 380px;
            grid-template-rows: 70px 1fr;
            height: 100vh;
        }

        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: 250px 1fr 320px;
            }
        }

        @media (max-width: 1024px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "terminal controls"
                    "sidebar sidebar";
                grid-template-columns: 1fr 350px;
                grid-template-rows: 70px 1fr 200px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "terminal"
                    "controls"
                    "sidebar";
                grid-template-columns: 1fr;
                grid-template-rows: 70px 1fr auto auto;
                height: auto;
            }
        }

        .header {
            grid-area: header;
            background: rgba(0,0,0,0.95);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 25px;
            backdrop-filter: blur(20px);
            box-shadow: 0 1px 20px rgba(0,0,0,0.3);
        }

        .logo {
            font-size: 1.4rem;
            font-weight: 700;
            color: #00ff88;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .version-tag {
            font-size: 0.7rem;
            font-weight: 500;
            color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-btn {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .header-btn:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .sidebar {
            grid-area: sidebar;
            background: rgba(0,0,0,0.9);
            border-right: 1px solid rgba(255,255,255,0.1);
            padding: 25px;
            backdrop-filter: blur(20px);
            overflow-y: auto;
        }

        .sidebar h3 {
            color: #00ff88;
            margin-bottom: 16px;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            font-weight: 600;
        }

        .preset-item {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .preset-item:hover {
            background: rgba(255,255,255,0.08);
            transform: translateX(8px);
            border-color: rgba(0,255,136,0.3);
        }

        .preset-item.active {
            background: rgba(0,255,136,0.15);
            border-color: #00ff88;
        }

        .terminal-container {
            grid-area: terminal;
            padding: 25px;
            display: flex;
            flex-direction: column;
        }

        .terminal {
            flex: 1;
            background: rgba(0,0,0,0.95);
            border-radius: 16px;
            padding: 28px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 40px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            display: flex;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
        }

        .terminal-title {
            color: #00ff88;
            font-weight: 600;
            flex: 1;
            font-size: 1.1rem;
        }

        .terminal-stats {
            display: flex;
            gap: 20px;
            font-size: 0.85rem;
            opacity: 0.8;
            font-weight: 500;
        }

        .output {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 24px;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            min-height: 320px;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
        }

        .output::-webkit-scrollbar { width: 8px; }
        .output::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        .output::-webkit-scrollbar-thumb { background: rgba(0,255,136,0.4); border-radius: 4px; }

        .input-section { display: flex; gap: 12px; align-items: center; }
        .prompt { color: #00ff88; font-weight: 600; white-space: nowrap; font-size: 1rem; }

        .command-input {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
            font-size: 14px;
            outline: none;
            padding: 14px 18px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .command-input:focus {
            border-color: #00ff88;
            background: rgba(255,255,255,0.08);
            box-shadow: 0 0 0 2px rgba(0,255,136,0.2);
        }

        .send-btn {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            border: none;
            color: #000;
            padding: 14px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,255,136,0.4);
        }

        .controls-panel {
            grid-area: controls;
            background: rgba(0,0,0,0.9);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 25px;
            backdrop-filter: blur(20px);
            overflow-y: auto;
        }

        .control-section { margin-bottom: 28px; }

        .control-section h3 {
            color: #00ff88;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .control-btn {
            width: 100%;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff;
            padding: 14px 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-align: left;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.12);
            transform: translateX(6px);
            border-color: rgba(0,255,136,0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .mixer {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .visualizer-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            height: 120px;
            position: relative;
            overflow: hidden;
        }

        .visualizer-bars {
            display: flex;
            align-items: flex-end;
            height: 80px;
            gap: 2px;
            justify-content: space-around;
        }

        .viz-bar {
            background: linear-gradient(to top, #00ff88, #00d4ff, #ff6b9d);
            width: 3px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .error { color: #ff4757; }
        .success { color: #00ff88; }
        .info { color: #00d4ff; }
        .warning { color: #ffa502; }
        .ai { color: #ff6b9d; }
        .system { color: #7bed9f; }

        .api-key-setup {
            background: rgba(255,165,0,0.1);
            border: 1px solid #ffa502;
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 24px;
        }

        .api-input {
            width: 100%;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            color: #fff;
            margin: 12px 0;
            font-size: 0.9rem;
        }

        .performance-warning {
            background: rgba(255,165,0,0.1);
            border: 1px solid #ffa502;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            display: none;
        }
        .performance-warning.show { display: block; }

        .player-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
        }
        .player-indicator {
            display: inline-block; width: 8px; height: 8px;
            background: #00ff88; border-radius: 50%;
            margin-right: 8px;
        }

        /* --- HELP MODAL STYLES --- */
        .help-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(15px);
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .help-modal-content {
            background: #1e1e2d;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            animation: slideIn 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
        }
        
        @keyframes slideIn {
            from { transform: translateY(50px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .help-modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-modal-header h2 {
            color: #00ff88;
            font-size: 1.5rem;
        }

        .close-help-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 35px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .close-help-btn:hover {
            background: #ff4757;
            transform: rotate(90deg);
        }

        .help-modal-body {
            padding: 30px;
            overflow-y: auto;
            line-height: 1.7;
        }

        .help-modal-body h3 {
            color: #00d4ff;
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            padding-bottom: 5px;
        }
        .help-modal-body h3:first-child {
            margin-top: 0;
        }

        .help-modal-body p {
            margin-bottom: 15px;
            opacity: 0.9;
        }
        
        .help-modal-body code {
            background: rgba(0,0,0,0.5);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            color: #ff6b9d;
        }
        
        .help-modal-body ul {
            list-style-type: none;
            padding-left: 0;
        }
        .help-modal-body li {
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #00d4ff;
        }
    </style>
</head>
<body>
    <div class="audio-init-overlay" id="audioInitOverlay">
        <div class="audio-init-content">
            <h2 style="color: #00ff88; margin-bottom: 20px;">🎵 AI Music Co-pilot</h2>
            <p style="margin-bottom: 20px; opacity: 0.9;">
                Enable the professional audio engine for the best experience.
            </p>
            <button class="audio-init-btn" onclick="initializeAudio()">
                🚀 Enable Professional Audio
            </button>
        </div>
    </div>
    
    <div class="help-modal-overlay" id="helpModal">
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h2>📖 Co-pilot Manual</h2>
                <button class="close-help-btn" onclick="toggleHelpModal()">&times;</button>
            </div>
            <div class="help-modal-body">
                <h3>🎵 AI Music Co-pilot v6.0 - Complete Guide</h3>
                <p>Your advanced AI partner with musical intelligence, genre expertise, and learning capabilities. This system understands music theory, detects your mood, and adapts to your creative style.</p>
                
                <h3>🚀 Quick Start: Building Your First Track</h3>
                <ol>
                    <li><strong>Start with Rhythm:</strong> <code>"create a driving techno beat"</code> or <code>"give me a groovy house rhythm"</code></li>
                    <li><strong>Add Bass Foundation:</strong> <code>"add a pumping bassline with sidechain"</code> - AI detects genre and suggests compatible bass</li>
                    <li><strong>Layer Harmony:</strong> <code>"add some dark pads in minor"</code> or <code>"create uplifting major chords"</code></li>
                    <li><strong>Build Energy:</strong> <code>"make it more aggressive"</code> or <code>"add a screaming lead"</code></li>
                </ol>

                <h3>🎛️ Advanced Co-pilot Features</h3>
                <ul>
                    <li><strong>🎚️ Mix Suggestions:</strong> Real-time mixing advice based on your track analysis</li>
                    <li><strong>📝 Arrangement Ideas:</strong> Timeline-based structural suggestions for your track</li>
                    <li><strong>🎨 Style Transfer:</strong> Transform your track between genres while keeping core elements</li>
                    <li><strong>⚡ Energy Control:</strong> "Pump it up" or "make it chill" with intelligent adaptation</li>
                    <li><strong>🔄 Evolution Commands:</strong> "Evolve the drums" or "vary the bassline" for dynamic changes</li>
                    <li><strong>🧠 Learning System:</strong> AI remembers your preferences and suggests personalized ideas</li>
                </ul>

                <h3>🎭 Voice Commands & Mood Detection</h3>
                <p>The AI understands natural language and detects your creative mood:</p>
                <ul>
                    <li><strong>Energy Commands:</strong> "Make it more aggressive", "Pump it up", "Add some drive"</li>
                    <li><strong>Chill Commands:</strong> "Make it chill", "Tone it down", "Add some ambient vibes"</li>
                    <li><strong>Style Commands:</strong> "Daft Punk style", "Add some trance elements", "Make it more underground"</li>
                    <li><strong>Smart Effects:</strong> "Add pumping", "With long reverb", "Make it wobble"</li>
                </ul>

                <h3>🥁 Precision Drum Programming</h3>
                <p>Use pattern notation for exact control: <code>play drums "[pattern]"</code></p>
                <ul>
                    <li><code>x</code> - Kick Drum (4/4 foundation)</li>
                    <li><code>o</code> - Snare/Clap (backbeat)</li>
                    <li><code>h</code> - Closed Hi-Hat (rhythm detail)</li>
                    <li><code>H</code> - Open Hi-Hat (groove accent)</li>
                    <li><code>c</code> - Clap (percussive punch)</li>
                    <li><code>t</code> - Tom (fills and transitions)</li>
                    <li><code>-</code> - Rest (space and breathing)</li>
                </ul>
                <p><strong>Pro Examples:</strong><br>
                House: <code>"x-H-o-H-"</code><br>
                Techno: <code>"x-x-x-x-"</code><br>
                DnB: <code>"x-t-o-t-"</code></p>

                <h3>🎹 Musical Intelligence & Theory</h3>
                <p>The AI understands music theory and suggests harmonically correct progressions:</p>
                <ul>
                    <li><strong>Smart Chord Progressions:</strong> AI suggests I-V-vi-IV and other classic progressions</li>
                    <li><strong>Key Detection:</strong> Automatically detects your track's key and scale</li>
                    <li><strong>Genre Patterns:</strong> Knows characteristic patterns for House, Techno, Ambient, DnB, Trance</li>
                    <li><strong>Harmonic Compatibility:</strong> New elements automatically complement existing layers</li>
                </ul>

                <h3>🎚️ Enhanced Effects & Production</h3>
                <p>Add professional effects with natural language:</p>
                <ul>
                    <li><code>"with sidechain"</code> - Pumping effect synchronized to kick</li>
                    <li><code>"with long reverb"</code> - Spacious ambient tail</li>
                    <li><code>"with filter sweep"</code> - Dynamic frequency modulation</li>
                    <li><code>"with delay"</code> - Rhythmic echo effects</li>
                    <li><code>"make it wobble"</code> - LFO modulation for bass</li>
                </ul>

                <h3>📊 Learning & Memory System</h3>
                <ul>
                    <li><strong>💾 Save Templates:</strong> Preserve your favorite arrangements for later use</li>
                    <li><strong>📈 Learning Stats:</strong> View your genre preferences and creative patterns</li>
                    <li><strong>🎯 AI Suggestions:</strong> Get personalized ideas based on your history</li>
                    <li><strong>🔄 Auto-Save:</strong> System automatically learns from successful sessions</li>
                </ul>

                <h3>🎪 Pro Tips for Advanced Use</h3>
                <ul>
                    <li><strong>Layer Gradually:</strong> Start simple, let AI suggest the next layer</li>
                    <li><strong>Use Mood Words:</strong> "Dark", "uplifting", "aggressive", "dreamy" guide AI suggestions</li>
                    <li><strong>Experiment with Evolution:</strong> Use "evolve" commands to create variations</li>
                    <li><strong>Trust the AI:</strong> It understands music theory - let it guide harmonic choices</li>
                    <li><strong>Combine Commands:</strong> "Add a dark techno bassline with heavy sidechain compression"</li>
                </ul>

                <p><strong>Remember:</strong> The AI learns from every session and adapts to your creative style. The more you use it, the better it becomes at predicting your preferences!</p>
            </div>
        </div>
    </div>

    <div class="app-container">
        <header class="header">
            <a href="index.html" class="logo">
                🎵 AI Music Co-pilot <span class="version-tag">Evolution v5.4</span>
            </a>
            <div class="header-controls">
                <div class="status-indicator">
                    <span id="audioStatusText">Audio Disabled</span>
                </div>
                <button class="header-btn" onclick="toggleHelpModal()">📖 Help</button>
                <button class="header-btn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
                <button class="header-btn" onclick="shareProject()">🔗 Share</button>
            </div>
        </header>

        <aside class="sidebar">
            <div class="performance-warning" id="performanceWarning">
                ⚠️ <strong>Mobile Device Detected:</strong> Performance optimized.
            </div>

            <div class="api-key-setup" id="apiSetup">
                <h3>🔑 AI Setup</h3>
                <p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 8px;">Enable AI music generation</p>
                <input type="password" class="api-input" id="apiKeyInput" placeholder="Enter your Google AI API Key">
                <button class="control-btn" style="background: rgba(0,255,136,0.2); border-color: #00ff88;" onclick="setupAPI()">
                    Activate AI
                </button>
            </div>

            <div class="preset-list">
                <h3>🎼 Studio Presets v6.0</h3>
                <div class="preset-item" onclick="loadPreset('progressive-house')"><strong>🌅 Progressive House</strong><br><small style="opacity: 0.7;">Uplifting journey with evolving layers</small></div>
                <div class="preset-item" onclick="loadPreset('dark-techno')"><strong>🖤 Dark Techno</strong><br><small style="opacity: 0.7;">Industrial underground with heavy sidechain</small></div>
                <div class="preset-item" onclick="loadPreset('future-bass')"><strong>💫 Future Bass</strong><br><small style="opacity: 0.7;">Modern drops with emotional chords</small></div>
                <div class="preset-item" onclick="loadPreset('minimal-deep')"><strong>🌊 Minimal Deep</strong><br><small style="opacity: 0.7;">Hypnotic groove with subtle textures</small></div>
                <div class="preset-item" onclick="loadPreset('euphoric-trance')"><strong>✨ Euphoric Trance</strong><br><small style="opacity: 0.7;">Soaring leads with pumping energy</small></div>
                <div class="preset-item" onclick="loadPreset('ambient-cinematic')"><strong>🎬 Cinematic Ambient</strong><br><small style="opacity: 0.7;">Atmospheric soundscape with movement</small></div>
            </div>
        </aside>

        <main class="terminal-container">
            <div class="terminal">
                <div class="terminal-header">
                    <div class="terminal-title">Evolution Audio Engine v5.4</div>
                    <div class="terminal-stats">
                        <span>BPM: <span id="bpmDisplay">120</span></span>
                        <span>⏱️ <span id="timeDisplay">00:00</span></span>
                        <span>Active: <span id="activeCount">0</span></span>
                    </div>
                </div>
                
                <div class="output" id="output"></div>
                
                <div class="input-section">
                    <div class="prompt">🎧 ></div>
                    <input type="text" class="command-input" id="commandInput" placeholder="Describe your musical vision..." autofocus>
                    <button class="send-btn" id="sendBtn" onclick="processCommand()">Create</button>
                </div>
            </div>
        </main>

        <aside class="controls-panel">
            <div class="visualizer-container">
                <div class="visualizer-bars" id="visualizerBars"></div>
            </div>

            <div class="control-section">
                <h3>🎚️ Master Section</h3>
                <div class="mixer">
                    <div style="display: flex; align-items: center; margin-bottom: 14px;">
                        <div style="width: 35px; font-size: 0.8rem; color: #00ff88;">VOL</div>
                        <input type="range" style="flex: 1; margin: 0 12px;" id="masterVolume" min="0" max="1" step="0.02" value="0.7" oninput="setMasterVolume(this.value)">
                        <div style="width: 40px; font-size: 0.8rem; text-align: right;" id="volumeDisplay">70%</div>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <div style="width: 35px; font-size: 0.8rem; color: #00ff88;">BPM</div>
                        <input type="range" style="flex: 1; margin: 0 12px;" id="masterTempo" min="80" max="180" value="120" oninput="setTempo(this.value)">
                        <div style="width: 40px; font-size: 0.8rem; text-align: right;" id="tempoDisplay">120</div>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>✨ AI Co-pilot</h3>
                <button class="control-btn" id="analyzeBtn" onclick="analyzeTrack()">🧠 ✨ Analyze Track</button>
                <button class="control-btn" id="nameTrackBtn" onclick="nameMyTrack()">🏷️ ✨ Name My Track</button>
            </div>

            <div class="control-section">
                <h3>⏯️ Transport & State</h3>
                <button class="control-btn" style="background: rgba(255,71,87,0.2); border-color: #ff4757;" onclick="stopAllSounds()">⏹️ Stop All</button>
                <button class="control-btn" onclick="showCurrentState()">🎼 View AI State</button>
                <button class="control-btn" onclick="clearTerminal()">🧹 Clear Log</button>
            </div>

            <div class="control-section">
                <h3>🎵 Live Players</h3>
                <div class="mixer" id="playersState">
                    <div class="info" style="text-align: center; opacity: 0.6; font-size: 0.85rem;">No active players</div>
                </div>
            </div>
        </aside>
    </div>

    <script>
    // ===== EVOLUTION AUDIO ENGINE v6.3 (AImCo_evo2) =====
    // MAJOR UPGRADE: Implemented a new AI prompting strategy.
    // The AI now returns a structured JSON object containing both a 'command' for execution
    // and a detailed 'metadata' object for state management, inspired by the FoxDot version.
    // This makes our state infinitely richer and our code cleaner.
    
    let audioContext = null;
    let masterGain = null;
    // ... (rest of the initial variables are the same)
    let sidechainGain = null;
    let analyser = null;
    let audioInitialized = false;
    let isMobileDevice = false;
    let maxConcurrentOscillators = 24;
    
    let currentTempo = 120;
    let apiKey = '';
    let startTime = Date.now();
    let musicState = {}; 
    
    let activePlayers = {}; //-- NEW: This will store the audio nodes for live control.
    
    //-- FIXED: Complete list of all valid instrument types including 'hihats' and 'drums'
    const PLAYABLE_INSTRUMENT_TYPES = [
        'drum', 'drums', 'bass', 'lead', 'pads', 'hi-hat', 'hihats', 'kick', 'snare', 'clap', 'tom', 
        'cymbal/crash', 'ride', 'percussion', 'acid-bass', 'arpeggiated-synth', 
        'string-synth', 'pluck-synth', 'white-noise/sweep', 'chords', 'vocal-chop/sample'
    ];

    // --- CORE AUDIO & COMPONENTS (No changes here) ---
    // (detectMobileDevice, initializeAudio, ensureAudioContext, BulletproofADSR, OscillatorPool, PrecisionScheduler, createBulletproofOscillator, createBulletproofDrum all remain the same)
    
    //-- NEW: A helper function to translate musical notation into MIDI numbers.
    function noteToMidi(noteName) {
        const noteMap = { 'c': 0, 'c#': 1, 'db': 1, 'd': 2, 'd#': 3, 'eb': 3, 'e': 4, 'f': 5, 'f#': 6, 'gb': 6, 'g': 7, 'g#': 8, 'ab': 8, 'a': 9, 'a#': 10, 'bb': 10, 'b': 11 };
        const match = noteName.toLowerCase().match(/^([a-g][#b]?)-?(\d+)/);

        if (!match) return null; // Return null if the format is invalid

        const note = noteMap[match[1]];
        const octave = parseInt(match[2], 10);

        // Our engine's "0" is C4. MIDI standard "0" is C-1. We need to adjust.
        // MIDI for C4 is 60. So we'll calculate the MIDI note and then subtract 60.
        const midiNote = 12 * (octave + 1) + note;
        return midiNote - 60; // Adjust to our C4=0 standard
    }

    //-- NEW: A function to control the volume of an active player.
    function setPlayerVolume(player, volume) { // volume is 0.0 to 1.0
        if (activePlayers[player] && activePlayers[player].gainNode) {
            const gainNode = activePlayers[player].gainNode;

            // Clamp the volume to a safe range (e.g., 0.0 to 1.5)
            const clampedVolume = Math.max(0, Math.min(1.5, volume));

            gainNode.gain.setValueAtTime(clampedVolume, audioContext.currentTime);
            addOutput(`🔊 Volume for ${player.toUpperCase()} set to ${Math.round(clampedVolume * 100)}%`, 'info');
        } else {
            addOutput(`🤔 Player ${player.toUpperCase()} not found. Can't set volume.`, 'warning');
        }
    }
    
    function detectMobileDevice() {
        let isMobileDevice = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
            window.matchMedia("(max-width: 768px)").matches;
        if (isMobileDevice) {
            let maxConcurrentOscillators = 12;
            const warningElement = document.getElementById('performanceWarning');
            if (warningElement) {
                warningElement.classList.add('show');
            }
        }
        return isMobileDevice;
    }
    async function initializeAudio() {
        if (audioInitialized) return true;
        try {
            document.getElementById('audioInitOverlay').style.display = 'none';
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContextClass({ latencyHint: isMobileDevice ? 'interactive' : 'playback', sampleRate: isMobileDevice ? 44100 : 48000 });
            if (audioContext.state === 'suspended') await audioContext.resume();
            masterGain = audioContext.createGain();
            sidechainGain = audioContext.createGain();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            masterGain.connect(sidechainGain);
            sidechainGain.connect(analyser);
            analyser.connect(audioContext.destination);
            masterGain.gain.value = 0.7;
            audioInitialized = true;
            document.getElementById('audioStatusText').textContent = `Audio Ready (${audioContext.sampleRate/1000}kHz)`;
            addOutput('🎵 Evolution Audio Engine Initialized!', 'system');
            initVisualizer();
            return true;
        } catch (error) {
            document.getElementById('audioStatusText').textContent = 'Audio Failed';
            addOutput(`❌ Audio initialization failed: ${error.message}`, 'error');
            return false;
        }
    }
    async function ensureAudioContext() {
        if (!audioInitialized) { return await initializeAudio(); }
        if (audioContext.state === 'suspended') await audioContext.resume();
        return true;
    }
    class BulletproofADSR {
        constructor(audioContext, gainNode) { this.context = audioContext; this.gain = gainNode; }
        trigger(attack = 0.01, decay = 0.3, sustain = 0.7, release = 0.5, duration = 1) {
            const now = this.context.currentTime;
            const sustainTime = Math.max(0, duration - attack - decay - release);
            this.gain.gain.cancelScheduledValues(now); this.gain.gain.setValueAtTime(0.001, now);
            this.gain.gain.linearRampToValueAtTime(1, now + attack); this.gain.gain.linearRampToValueAtTime(sustain, now + attack + decay);
            this.gain.gain.setValueAtTime(sustain, now + attack + decay + sustainTime);
            this.gain.gain.linearRampToValueAtTime(0.001, now + attack + decay + sustainTime + release);
        }
    }
    class OscillatorPool {
        constructor() { this.activeNodes = new Set(); }
        createNode(type) {
            this.cleanup();
            if (this.activeNodes.size >= maxConcurrentOscillators) { addOutput(`⚠️ Audio limit reached.`, 'warning'); return null; }
            let node;
            if (type === 'osc' || type === 'lfo') node = audioContext.createOscillator();
            else if (type === 'noise') {
                const bufferSize = audioContext.sampleRate * 0.5; const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                node = audioContext.createBufferSource(); node.buffer = buffer; node.loop = false;
            }
            const gain = audioContext.createGain(); const nodeGroup = { node, gain, finished: false };
            this.activeNodes.add(nodeGroup); node.onended = () => { nodeGroup.finished = true; this.cleanup(); };
            return nodeGroup;
        }
        cleanup() { for (const nodeGroup of this.activeNodes) { if (nodeGroup.finished) { try { nodeGroup.node.disconnect(); nodeGroup.gain.disconnect(); } catch (e) {} this.activeNodes.delete(nodeGroup); } } }
        stopAll() {
            const now = audioContext.currentTime;
            for (const nodeGroup of this.activeNodes) {
                try {
                    nodeGroup.gain.gain.cancelScheduledValues(now); nodeGroup.gain.gain.setValueAtTime(nodeGroup.gain.gain.value, now);
                    nodeGroup.gain.gain.linearRampToValueAtTime(0.001, now + 0.1); if(nodeGroup.node.stop) nodeGroup.node.stop(now + 0.1);
                } catch (e) {}
            }
        }
    }
    const oscillatorPool = new OscillatorPool();
    class PrecisionScheduler {
        constructor() { this.scheduledEvents = new Map(); this.nextEventId = 0; }
        schedule(callback, delayInSeconds) { const id = this.nextEventId++; const timeoutId = setTimeout(() => { callback(); this.scheduledEvents.delete(id); }, delayInSeconds * 1000); this.scheduledEvents.set(id, { timeoutId }); return id; }
        cancel(eventId) { const event = this.scheduledEvents.get(eventId); if (event) { clearTimeout(event.timeoutId); this.scheduledEvents.delete(eventId); } }
        cancelAll() { for (const event of this.scheduledEvents.values()) { clearTimeout(event.timeoutId); } this.scheduledEvents.clear(); }
    }
    const scheduler = new PrecisionScheduler();
    // REMOVED: Incomplete oscillator function - using the complete version below

    // --- EVOLVED AI & COMMAND PROCESSING v6.3 (AImCo_evo2) ---

    function getMusicStateSummary() {
        const activePlayers = Object.entries(musicState)
            .filter(([_, data]) => data.status === 'playing')
            .reduce((obj, [key, val]) => {
                const { nextEventId, ...rest } = val; 
                obj[key] = rest;
                return obj;
            }, {});
        
        if (Object.keys(activePlayers).length === 0) return "The musical canvas is empty.";
        return JSON.stringify(activePlayers, null, 2);
    }

    //-- MODIFIED: The AI 'brain' is replaced with our new hybrid prompt.
    async function callGeminiAPI(prompt, currentStateSummary) {
        if (!apiKey) {
            addOutput('❌ Please configure your API key in the sidebar.', 'error');
            return null;
        }
        addOutput('🤖 AI producer is analyzing the track...', 'ai');

        const systemInstruction = `You are an elite electronic music producer AI. You will receive a user's idea and the current musical state.
Your entire response MUST be a single, valid JSON object with a "layers" key.
"layers" must be an array of objects, where each object has a "command" string and a "metadata" object.

--- METADATA REQUIREMENTS ---
- For ALL layers (drums, bass, etc.), include "player", "type", and any other relevant musical info.
- MELODIC types ("bass", "lead", "pads"): include "preset", "notes" (as an array of numbers).
- DRUM type ("drum"): include "pattern" (as a rhythm string).
- STOP actions: The command should be "stop [player]" and metadata must include "player" and "action: 'stop'".
- EFFECTS: If the user mentions effects, include an "effects" object in the metadata (e.g., {"sidechain": true}).

--- EXAMPLE WORKFLOW ---

1. User Request: "a simple house beat"
   Current State: "The musical canvas is empty."
   Your JSON Response:
   {
     "layers": [
       {
         "command": "play drums 'x-H-o-H-'",
         "metadata": { "player": "d1", "type": "drum", "pattern": "x-H-o-H-" }
       }
     ]
   }

2. User Request: "add some dreamy pads"
   Current State: { "d1": { "type": "drum", "pattern": "x-H-o-H-" } }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "play pads [0, 4, 7, 11] as sine-pad with pumping and long reverb",
         "metadata": {
           "player": "p1", "type": "pads", "preset": "sine-pad",
           "notes": [0, 4, 7, 11], "effects": { "sidechain": true, "reverb": "long" }
         }
       }
     ]
   }

3. User Request: "stop the drums"
   Current State: { "d1": ..., "p1": ... }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "stop d1",
         "metadata": { "player": "d1", "action": "stop" }
       }
     ]
   }

4.  User Request: "set tempo to 90 bpm"
    Current State: { ... }
    Your JSON Response:
    {
      "layers": [
        {
          "command": "set tempo 90",
          "metadata": { "action": "set_tempo", "value": 90 }
        }
    ]
}

5. User Request: "bass volume 50%"
   Current State: { "b1": { "type": "bass", ... } }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "set volume b1 50%",
         "metadata": { "action": "set_volume", "player": "b1", "value": "50" }
       }
     ]
   }

User Request: "${prompt}"
Current Musical State: ${currentStateSummary}`;

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: systemInstruction }] }],
                    generationConfig: { temperature: 0.9, maxOutputTokens: 800, responseMimeType: "application/json" }
                })
            });
            
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();
            const text = data.candidates[0].content.parts[0].text;
            const result = JSON.parse(text);
            
            if (result.layers && Array.isArray(result.layers)) {
                addOutput(`🎵 AI generated ${result.layers.length} new musical layer(s).`, 'ai');
                return result.layers;
            }
            throw new Error("Invalid format from AI: 'layers' array not found.");
        } catch (error) {
            addOutput(`❌ AI API Error: ${error.message}`, 'error');
            console.error(error); return null;
        }
    }
    
    //-- MODIFIED: This function now handles the new, richer JSON structure.
    async function executeCommands(prompt) {
        const currentStateSummary = getMusicStateSummary();
        const commandLayers = await callGeminiAPI(prompt, currentStateSummary);

        if (commandLayers && commandLayers.length > 0) {
            for (const [index, layer] of commandLayers.entries()) {
                setTimeout(() => {
                    const { command, metadata } = layer;
                    if (!command || !metadata) {
                        addOutput(`🤔 AI response layer was malformed.`, 'warning');
                        return;
                    }
                    
                    // Assign a player name if the AI didn't.
                    if (!metadata.player && metadata.type) {
                        metadata.player = getNextPlayer(metadata.type.charAt(0));
                    }

                    executeDirectCommand(command, metadata);
                    updateMusicState(metadata.player, metadata);

                }, index * 200);
            }
        }
    }
    
    //-- MODIFIED: We no longer need to parse commands for metadata.
    // The AI gives it to us directly. This function is much simpler.
    //-- MODIFIED: This function is now more robust and won't crash on incomplete metadata.
    //-- MODIFIED: This function can now understand tempo changes.
    
    function executeDirectCommand(command, metadata) {
        try {
            addOutput(`✅ Executing: ${command}`, 'success');

            // --- PRIORITY ACTIONS ---
            // Check for specific actions first, as they don't have an instrument 'type'.
            if (metadata.action === 'stop') {
                stopPlayer(metadata.player);
                return;
            } 
            else if (metadata.action === 'set_tempo') {
                const tempoValue = parseInt(metadata.value, 10);
                if (!isNaN(tempoValue)) {
                    setTempo(tempoValue);
                    document.getElementById('masterTempo').value = tempoValue;
                }
                return;
            }
            else if (metadata.action === 'set_volume') {
                const volumeValue = parseFloat(metadata.value) / 100.0;
                if (!isNaN(volumeValue)) {
                    setPlayerVolume(metadata.player, volumeValue);
                }
                return;
            }

            // --- INSTRUMENT PLAYBACK ---
            // If it's not a priority action, check if it's a playable instrument type.
            if (!metadata.type) {
                addOutput(`🤔 AI suggested a command I don't understand yet: "${command}"`, 'warning');
                return;
            }
            
            if (PLAYABLE_INSTRUMENT_TYPES.includes(metadata.type)) {
                startBulletproofPlayer(metadata.player, metadata);
            } else {
                addOutput(`🤔 Unknown metadata type: "${metadata.type}"`, 'warning');
            }

        } catch (error) {
            addOutput(`❌ Command execution error: ${error.message}`, 'error');
            console.error(error);
        }
    }

    //-- MODIFIED: State update is cleaner now.
    function updateMusicState(player, metadata) {
        if (!player) return;

        if (metadata.action === 'stop') {
            if (musicState[player]) {
                 musicState[player].status = 'stopped';
            }
        } else { 
            musicState[player] = { ...metadata, status: 'playing' }; 
        }
        updatePlayersDisplay();
    }

    // --- PLAYER & PATTERN LOGIC ---
    //-- MODIFIED: This function now gets the full metadata object.
    //-- MODIFIED: This function now creates the main gain node for the player.
function startBulletproofPlayer(player, config) {
    if (activePlayers[player]) {
        // If the player exists, stop its previous scheduler
        scheduler.cancel(musicState[player]?.nextEventId);
    }

    // Create a dedicated gain node for this player
    const playerGain = audioContext.createGain();
    const destination = config.effects?.sidechain ? sidechainGain : masterGain;
    playerGain.connect(destination);

    // Store the player's components for later control
    activePlayers[player] = { gainNode: playerGain };
    musicState[player] = { ...config, status: 'playing' };

    if (config.type.match(/drum|hi-hat|kick|snare/)) {
        playBulletproofPattern(player, config.pattern, config.effects || {}, playerGain);
    } else {
        const octave = config.type === 'bass' ? 3 : 4;
        playBulletproofMelody(player, config.notes, { ...config, octave }, playerGain);
    }
}

    //-- UPGRADED & CORRECTED: This is the complete, final version of the synthesizer function.
    function createBulletproofOscillator(frequency, preset = 'saw-lead', duration = 1, effects = {}, destinationNode) {
        if (!ensureAudioContext()) return null;
        
        const oscGroup = oscillatorPool.createNode('osc');
        if (!oscGroup) return null; // This safety check is important!

        const { node: osc, gain: envelopeGain } = oscGroup;
        const filter = audioContext.createBiquadFilter();
        const distortion = audioContext.createWaveShaper();
        
        let waveform = 'sawtooth', amp = 0.3;
        let attack = 0.02, decay = 0.3, sustain = 0.7, release = 0.5;

        if (preset === 'sine-pad') { waveform = 'sine'; attack = 0.8; release = 1.5; amp = 0.4; }
        if (preset === 'square-bass') { waveform = 'square'; attack = 0.01; release = 0.3; amp = 0.5; }

        osc.type = waveform;
        osc.frequency.setValueAtTime(frequency, audioContext.currentTime);

        filter.type = 'lowpass';
        filter.frequency.value = 20000; 
        filter.Q.value = 1;

        if (effects.filter) {
            filter.type = effects.filter.type || 'lowpass';
            filter.frequency.setValueAtTime(effects.filter.frequency || 5000, audioContext.currentTime);
            filter.Q.value = effects.filter.q || 1;
        }

        if (effects.saturation) {
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; ++i) {
                const x = i * 2 / 255 - 1;
                curve[i] = (Math.PI + effects.saturation) * x / (Math.PI + effects.saturation * Math.abs(x));
            }
            distortion.curve = curve;
            osc.connect(distortion);
            distortion.connect(filter);
        } else {
            osc.connect(filter);
        }
        
        const stopTime = audioContext.currentTime + duration + release + 0.5;
        
        if (effects.lfo && effects.lfo.target === 'filter') {
            const lfoGroup = oscillatorPool.createNode('lfo');
            if (lfoGroup) {
                const { node: lfo, gain: lfoGain } = lfoGroup;
                lfo.type = 'sine';
                lfo.frequency.value = effects.lfo.rate || 4;
                lfoGain.gain.value = effects.lfo.amount || 100;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();
                lfo.stop(stopTime);
            }
        }

        const envelope = new BulletproofADSR(audioContext, envelopeGain);
        filter.connect(envelopeGain);
        
        // This is the corrected routing logic for volume control
        envelopeGain.connect(destinationNode); 
        
        const finalAmp = effects.amp || amp;
        // We trigger the envelope on its own gain, not the player's main gain.
        envelope.trigger(attack, decay, sustain, release, duration);
        
        osc.start();
        osc.stop(stopTime);
    }
    // We also need to slightly modify the drum and pattern functions to pass the destinationNode down.
    function playBulletproofPattern(player, pattern, effects, playerGain) {
        // ...
        function scheduleNextBeat() {
            // ...
            if (char !== '-' && char !== ' ') createBulletproofDrum(char, effects, playerGain);
            // ...
        }
        scheduleNextBeat();
    }
    // FIXED: Complete and working drum synthesis implementation
    function createBulletproofDrum(type, effects = {}, destinationNode = masterGain) {
        if (!ensureAudioContext()) return; 
        const now = audioContext.currentTime;
        const amp = effects.amp || 1.0; // Default to 1.0 if no amp is provided
        
        if (type === 'kick' || type === 'x') {
            const oscGroup = oscillatorPool.createNode('osc'); 
            if(!oscGroup) return; 
            const { node: osc, gain } = oscGroup; 
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(1 * amp, now); // Apply amp
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.frequency.setValueAtTime(120, now); 
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
            
            osc.connect(gain); 
            gain.connect(destinationNode); 
            osc.start(now); 
            osc.stop(now + 0.2);
            
            // Sidechain effect
            if (sidechainGain && effects.sidechain) { 
                sidechainGain.gain.cancelScheduledValues(now); 
                sidechainGain.gain.setValueAtTime(sidechainGain.gain.value, now); 
                sidechainGain.gain.linearRampToValueAtTime(0.3, now + 0.01); 
                sidechainGain.gain.linearRampToValueAtTime(1.0, now + 0.25); 
            }
        } else if (type === 'snare' || type === 'o') {
            const noiseGroup = oscillatorPool.createNode('noise'); 
            const oscGroup = oscillatorPool.createNode('osc'); 
            if(!noiseGroup || !oscGroup) return;
            
            const { node: noise, gain: noiseGain } = noiseGroup; 
            const { node: osc, gain: oscGain } = oscGroup; 
            const filter = audioContext.createBiquadFilter();
            
            filter.type = 'highpass'; 
            filter.frequency.value = 1500; 
            noise.connect(filter); 
            filter.connect(noiseGain); 
            noiseGain.connect(destinationNode);
            
            osc.type = 'triangle'; 
            osc.frequency.value = 180; 
            osc.connect(oscGain); 
            oscGain.connect(destinationNode);
            
            noiseGain.gain.setValueAtTime(0.8 * amp, now); // Apply amp
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            oscGain.gain.setValueAtTime(0.7 * amp, now); // Apply amp
            oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            
            noise.start(now); 
            noise.stop(now + 0.2); 
            osc.start(now); 
            osc.stop(now + 0.1);
        } else if (type === 'hihat' || type === 'h' || type === '.') {
            const noiseGroup = oscillatorPool.createNode('noise'); 
            if(!noiseGroup) return; 
            const { node: noise, gain } = noiseGroup;
            const filter = audioContext.createBiquadFilter(); 
            
            filter.type = 'highpass'; 
            filter.frequency.value = 8000; 
            noise.connect(filter); 
            filter.connect(gain); 
            gain.connect(destinationNode);
            
            gain.gain.setValueAtTime(0.3, now); 
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); 
            noise.start(now); 
            noise.stop(now + 0.1);
        } else if (type === 'open-hihat' || type === 'H') {
            const noiseGroup = oscillatorPool.createNode('noise'); 
            if(!noiseGroup) return; 
            const { node: noise, gain } = noiseGroup;
            const filter = audioContext.createBiquadFilter(); 
            
            filter.type = 'highpass'; 
            filter.frequency.value = 7000; 
            noise.connect(filter); 
            filter.connect(gain); 
            gain.connect(destinationNode);
            
            gain.gain.setValueAtTime(0.4, now); 
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4); 
            noise.start(now); 
            noise.stop(now + 0.5);
        } else if (type === 'clap' || type === 'c') {
            const noiseGroup = oscillatorPool.createNode('noise'); 
            if(!noiseGroup) return; 
            const { node: noise, gain } = noiseGroup;
            const filter = audioContext.createBiquadFilter(); 
            
            filter.type = 'bandpass'; 
            filter.frequency.value = 1500; 
            filter.Q.value = 2;
            noise.connect(filter); 
            filter.connect(gain); 
            gain.connect(destinationNode); 
            
            gain.gain.setValueAtTime(0, now); 
            gain.gain.linearRampToValueAtTime(1, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); 
            noise.start(now); 
            noise.stop(now + 0.15);
        } else if (type === 'tom' || type === 't') {
            const oscGroup = oscillatorPool.createNode('osc'); 
            if(!oscGroup) return; 
            const { node: osc, gain } = oscGroup; 
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0.8, now); 
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.frequency.setValueAtTime(200, now); 
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
            
            osc.connect(gain); 
            gain.connect(destinationNode); 
            osc.start(now); 
            osc.stop(now + 0.3);
        }
    }
    function playBulletproofPattern(player, pattern, effects = {}, playerGain = masterGain) {
        const beatDuration = 60 / currentTempo / 4;
        let currentBeat = 0;
        
        function scheduleNextBeat() {
            if (!musicState[player] || musicState[player].status !== 'playing') return;
            const char = pattern[currentBeat % pattern.length];
            if (char !== '-' && char !== ' ') {
                createBulletproofDrum(char, effects, playerGain);
            }
            currentBeat++;
            musicState[player].nextEventId = scheduler.schedule(scheduleNextBeat, beatDuration);
        }
        scheduleNextBeat();
    }
    //-- MODIFIED: This function is now smarter and can handle both numbers and note names.
    function playBulletproofMelody(player, notes, config, playerGain = masterGain) {
        const noteDuration = 60 / currentTempo;
        let currentNoteIndex = 0;

        // --- NEW: Check if notes is a string and split it into an array ---
        let notesArray = notes;
        if (typeof notesArray === 'string') {
            // Split by space or hyphen
            notesArray = notesArray.split(/[\s-]+/);
        }
        // Safety check if the input was not an array or a string
        if (!Array.isArray(notesArray)) {
            addOutput(`❌ Invalid notes format for player ${player}. Expected an array.`, 'error');
            return;
        }
        
        function scheduleNextNote() {
            if (!musicState[player] || musicState[player].status !== 'playing') return;

            let noteValue = notesArray[currentNoteIndex % notesArray.length];

            if (typeof noteValue === 'string') {
                noteValue = noteToMidi(noteValue.trim()); // trim whitespace
            }

            if (noteValue === null || isNaN(noteValue)) {
                addOutput(`🤔 Skipping invalid note: "${notesArray[currentNoteIndex % notesArray.length]}"`, 'warning');
            } else {
                const frequency = 440 * Math.pow(2, (noteValue + 3 + (config.octave - 4) * 12) / 12);
                createBulletproofOscillator(frequency, config.preset, noteDuration * 0.8, config.effects || {}, playerGain);
            }
            
            currentNoteIndex++;
            musicState[player].nextEventId = scheduler.schedule(scheduleNextNote, noteDuration);
        }
        scheduleNextNote();
    }


    // --- UI & CONTROL FUNCTIONS ---
    async function processCommand() {
        if (!await ensureAudioContext()){ addOutput('❌ Audio not enabled.', 'error'); return; }
        const input = document.getElementById('commandInput');
        const commandText = input.value.trim();
        if (!commandText) return;
        addOutput(`🎧 > ${commandText}`, 'info');
        input.value = '';
        
        const command = commandText.toLowerCase();
        switch(command) {
            case 'help': toggleHelpModal(); return;
            case 'clear': clearTerminal(); return;
            case 'stop all': stopAllSounds(); return;
            case 'state': showCurrentState(); return;
            default: executeCommands(commandText); // Pass original casing
        }
    }
    
    function stopPlayer(player) {
        if (musicState[player]) {
            if (musicState[player].nextEventId) scheduler.cancel(musicState[player].nextEventId);
            musicState[player].status = 'stopped';
            addOutput(`🛑 Player ${player.toUpperCase()} stopped.`, 'info');
            updatePlayersDisplay();
        }
    }
    // (The rest of the UI and control functions are mostly unchanged)
    function setupAPI() { const input = document.getElementById('apiKeyInput'); apiKey = input.value.trim(); if (apiKey) { document.getElementById('apiSetup').style.display = 'none'; addOutput('✅ AI features activated!', 'success'); } }
    function addOutput(text, type = 'info') { const output = document.getElementById('output'); const div = document.createElement('div'); div.className = type; div.textContent = `[${new Date().toLocaleTimeString('en-GB', { timeZone: 'Europe/London' })}] ${text}`; output.appendChild(div); output.scrollTop = output.scrollHeight; if (output.children.length > 100) output.removeChild(output.children[0]); }
    function setMasterVolume(value) { if (masterGain) masterGain.gain.value = value; document.getElementById('volumeDisplay').textContent = `${Math.round(value * 100)}%`; }
    function setTempo(value) { currentTempo = parseInt(value); document.getElementById('tempoDisplay').textContent = value; document.getElementById('bpmDisplay').textContent = value; }
    function stopAllSounds() { 
        scheduler.cancelAll(); 
        if (audioInitialized) oscillatorPool.stopAll(); 
        musicState = {}; 
        activePlayers = {}; // Clear the active players as well
        addOutput('🛑 All sounds stopped & state cleared.', 'success'); 
        updatePlayersDisplay(); 
    }
    function clearTerminal() { document.getElementById('output').innerHTML = ''; addOutput('🎵 Evolution terminal ready.', 'system'); }
    function updatePlayersDisplay() { const display = document.getElementById('playersState'); const activePlayers = Object.entries(musicState).filter(([_, data]) => data.status === 'playing'); if (activePlayers.length === 0) { display.innerHTML = '<div class="info" style="text-align: center; opacity: 0.6; font-size: 0.85rem;">No active players</div>'; } else { display.innerHTML = activePlayers.map(([player, config]) => { let icon = '🎵'; if (config.type === 'drum') icon = '🥁'; else if (config.type === 'bass') icon = '🎸'; else if (config.type === 'lead') icon = '🎹'; else if (config.type === 'pads') icon = '🌊'; return `<div class="player-info"><div><span class="player-indicator"></span> ${icon} ${player.toUpperCase()}: ${config.type}</div> <button onclick="stopPlayer('${player}')" style="background:none; border:none; color:#ff4757; cursor:pointer;">×</button></div>`; }).join(''); } document.getElementById('activeCount').textContent = activePlayers.length; }
    function getNextPlayer(type) { let i = 1; while (musicState[`${type}${i}`]) i++; return `${type}${i}`; }
    function toggleHelpModal() { const modal = document.getElementById('helpModal'); modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex'; }
    function showCurrentState() { const summary = getMusicStateSummary(); addOutput('🧠 Current AI Memory (State):', 'system'); addOutput(summary, 'info'); }
    function setAiButtonsLoading(isLoading) { document.getElementById('analyzeBtn').disabled = isLoading; document.getElementById('nameTrackBtn').disabled = isLoading; if (isLoading) { document.getElementById('analyzeBtn').textContent = '🧠 ✨ Analyzing...'; document.getElementById('nameTrackBtn').textContent = '🏷️ ✨ Generating...'; } else { document.getElementById('analyzeBtn').textContent = '🧠 ✨ Analyze Track'; document.getElementById('nameTrackBtn').textContent = '🏷️ ✨ Name My Track'; } }
    async function callGeminiTextAPI(systemPrompt, userQuery) { if (!apiKey) { addOutput('❌ Please configure your API key first.', 'error'); return null; } if (Object.keys(musicState).filter(p => musicState[p].status === 'playing').length === 0) { addOutput('🤔 Your canvas is empty. Add music first!', 'warning'); return null; } setAiButtonsLoading(true); addOutput('✨ Calling the Gemini Co-pilot...', 'ai'); try { const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: userQuery }] }], systemInstruction: { parts: [{ text: systemPrompt }] } }) }); if (!response.ok) throw new Error(`API Error: ${response.status}`); const data = await response.json(); return data.candidates[0].content.parts[0].text; } catch (error) { addOutput(`❌ AI Co-pilot Error: ${error.message}`, 'error'); return null; } finally { setAiButtonsLoading(false); } }
    async function analyzeTrack() { const systemPrompt = "You are a friendly music theory professor. Analyze the provided musical data and give 3 concrete, inspiring suggestions for what the user could add next. Format with markdown bullet points."; const musicStateSummary = getMusicStateSummary(); const userQuery = `Analyze my track:\n\n${musicStateSummary}\n\nGive me a brief analysis and 3 suggestions.`; const result = await callGeminiTextAPI(systemPrompt, userQuery); if (result) { addOutput('--- AI Music Analysis ---', 'system'); result.split('\n').forEach(line => addOutput(line, 'ai')); addOutput('-------------------------', 'system'); } }
    async function nameMyTrack() { const systemPrompt = "You are a creative A&R scout. Your response MUST be a single, valid JSON object with 'title' and 'description' keys."; const musicStateSummary = getMusicStateSummary(); const userQuery = `Generate a track title and short description for this music:\n\n${musicStateSummary}`; const result = await callGeminiTextAPI(systemPrompt, userQuery); if (result) { try { const jsonMatch = result.match(/\{[\s\S]*\}/); if (!jsonMatch) throw new Error("No JSON found."); const parsed = JSON.parse(jsonMatch[0]); addOutput('--- AI Track Finalizer ---', 'system'); addOutput(`Title Suggestion: "${parsed.title}"`, 'success'); addOutput(`Description: ${parsed.description}`, 'info'); addOutput('-------------------------', 'system'); } catch (e) { addOutput('❌ AI returned an invalid format for the track name.', 'error'); console.error(e, "Raw response:", result); } } }
    function initVisualizer() { const container = document.getElementById('visualizerBars'); const barCount = 32; for (let i = 0; i < barCount; i++) container.appendChild(document.createElement('div')).className = 'viz-bar'; function update() { if (analyser) { const dataArray = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(dataArray); const bars = container.children; for (let i = 0; i < bars.length; i++) { const height = (dataArray[i * 2] / 255) * 100; bars[i].style.height = `${height}%`; } } requestAnimationFrame(update); } update(); }
    const presets = {
        'progressive-house': [
            {
                delay: 0, // Starts immediately
                metadata: { type: 'drum', pattern: 'x-hH-o-hH-x-hH-o-hH' } // More complex hi-hat pattern
            },
            {
                delay: 8000, // Starts after 4 bars (at 120bpm)
                metadata: { type: 'bass', preset: 'square-bass', notes: [0, 0, 5, 7], amp: 0.8, effects: { sidechain: true } }
            },
            {
                delay: 16000, // Starts after 8 bars
                metadata: { type: 'pads', preset: 'sine-pad', notes: [0, 4, 7, 11], amp: 0.6, effects: { reverb: 'long' } }
            },
            {
                delay: 24000, // Starts after 12 bars
                metadata: { 
                    type: 'lead', 
                    preset: 'lead', 
                    notes: [12, 16, 19, 16, 14, 16, 12], // More melodic phrase
                    amp: 0.7,
                    // We'll add filter effects here in the next step!
                    effects: { "filter": { "type": "lowpass", "frequency": 1200, "q": 5 }, "lfo": { "target": "filter", "rate": 4, "amount": 600 } }
                }
            }
        ],
        'dark-techno': [
            {
                delay: 0,
                metadata: { type: 'drum', pattern: 'x-x-c-x-', amp: 1.0 }
            },
            {
                delay: 4000,
                metadata: { 
                    type: 'bass', 
                    preset: 'square-bass', 
                    notes: [0, 0, 7, 3], 
                    amp: 0.9, 
                    effects: { sidechain: true, saturation: 0.3 } 
                }
            },
            {
                delay: 8000,
                metadata: { 
                    type: 'pads', 
                    preset: 'sine-pad', 
                    notes: [0, 3, 7, 10], 
                    amp: 0.5,
                    effects: { filter: { type: 'lowpass', frequency: 800, q: 2 } } 
                }
            }
        ],
        'future-bass': [
            {
                delay: 0,
                metadata: { type: 'drum', pattern: 'x-h-o-h-', amp: 0.8 }
            },
            {
                delay: 6000,
                metadata: { 
                    type: 'bass', 
                    preset: 'saw-lead', 
                    notes: [0, 7, 12, 7], 
                    amp: 0.8,
                    effects: { lfo: { target: 'filter', rate: 3, amount: 400 } }
                }
            },
            {
                delay: 12000,
                metadata: { 
                    type: 'pads', 
                    preset: 'sine-pad', 
                    notes: [0, 4, 7, 14], 
                    amp: 0.6,
                    effects: { reverb: 'long' }
                }
            }
        ],
        'minimal-deep': [
            {
                delay: 0,
                metadata: { type: 'drum', pattern: 'x---o---', amp: 0.7 }
            },
            {
                delay: 8000,
                metadata: { 
                    type: 'bass', 
                    preset: 'square-bass', 
                    notes: [0, 0, 0, 5], 
                    amp: 0.6,
                    effects: { sidechain: true }
                }
            },
            {
                delay: 16000,
                metadata: { 
                    type: 'pads', 
                    preset: 'sine-pad', 
                    notes: [0, 7, 12], 
                    amp: 0.4
                }
            }
        ],
        'euphoric-trance': [
            {
                delay: 0,
                metadata: { type: 'drum', pattern: 'x-o-x-o-', amp: 0.9 }
            },
            {
                delay: 4000,
                metadata: { 
                    type: 'bass', 
                    preset: 'square-bass', 
                    notes: [0, 5, 7, 12], 
                    amp: 0.8,
                    effects: { sidechain: true }
                }
            },
            {
                delay: 8000,
                metadata: { 
                    type: 'pads', 
                    preset: 'sine-pad', 
                    notes: [0, 4, 7, 11], 
                    amp: 0.7,
                    effects: { reverb: 'long' }
                }
            },
            {
                delay: 16000,
                metadata: { 
                    type: 'lead', 
                    preset: 'saw-lead', 
                    notes: [12, 16, 19, 24], 
                    amp: 0.6,
                    effects: { filter: { type: 'lowpass', frequency: 2000, q: 3 } }
                }
            }
        ],
        'ambient-cinematic': [
            {
                delay: 0,
                metadata: { 
                    type: 'pads', 
                    preset: 'sine-pad', 
                    notes: [0, 4, 7, 11, 14], 
                    amp: 0.5,
                    effects: { reverb: 'long' }
                }
            },
            {
                delay: 12000,
                metadata: { 
                    type: 'pads', 
                    preset: 'sine-pad', 
                    notes: [7, 11, 14, 19], 
                    amp: 0.4,
                    effects: { delay: true, reverb: 'long' }
                }
            },
            {
                delay: 24000,
                metadata: { 
                    type: 'bass', 
                    preset: 'sine-pad', 
                    notes: [0, 0, 0, 0], 
                    amp: 0.3
                }
            }
        ]
    };
    async function loadPreset(presetName) {
        if (!presets[presetName]) return;
        if (!await ensureAudioContext()) return;
        stopAllSounds();
        addOutput(`🎼 Loading ${presetName.toUpperCase()} preset...`, 'system');
        
        for (const layer of presets[presetName]) {
            // Use the new delay property!
            setTimeout(() => {
                const metadata = layer.metadata;
                if (metadata) {
                    // We no longer need to generate a command, we can just execute the metadata
                    const player = getNextPlayer(metadata.type.charAt(0));
                    metadata.player = player; // Assign a player name
                    
                    addOutput(`✅ Loading preset layer: ${metadata.type} on ${player.toUpperCase()}`, 'system');
                    startBulletproofPlayer(player, metadata);
                    updateMusicState(player, metadata);
                }
            }, layer.delay); // Use the delay from the preset object
        }
    }
    function shareProject() { alert('Project sharing feature coming soon!'); }
    function toggleFullscreen() { try { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { addOutput(`⚠️ Fullscreen error: ${err.message}`, 'warning'); }); } else { document.exitFullscreen(); } } catch (error) { console.error("Fullscreen error:", error); addOutput('⚠️ Fullscreen not permitted.', 'warning'); } }
    function updateTimeDisplay() { const elapsed = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsed / 60); const seconds = elapsed % 60; document.getElementById('timeDisplay').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
    window.addEventListener('load', () => { 
        detectMobileDevice(); 
        setInterval(updateTimeDisplay, 1000); 
        
        // Enhanced startup messages
        addOutput('🎵 Evolution Audio Engine v6.3 (AImCo_evo2) - Ready for Launch!', 'system'); 
        addOutput('🧠 Advanced AI Music Intelligence • Rich Metadata • Live Effects', 'system');
        addOutput('🎛️ Features: Volume Control • Sidechain • Filters • LFO Modulation', 'ai');
        addOutput('🎼 Enhanced Presets: Progressive House • Dark Techno • Future Bass', 'ai');
        addOutput('🚀 Click "Enable Professional Audio" to begin creating!', 'warning'); 
        
        // Performance info
        const cores = navigator.hardwareConcurrency || 'unknown';
        const memory = navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'unknown';
        addOutput(`💻 System: ${cores} cores • ${memory} RAM • Max oscillators: ${maxConcurrentOscillators}`, 'info');
    });
    document.getElementById('commandInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') processCommand(); });
</script>
</body>
</html>