<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Music Co-pilot - Evolution v5.4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .audio-init-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .audio-init-content {
            text-align: center;
            padding: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            max-width: 500px;
        }

        .audio-init-btn {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            border: none;
            color: #000;
            padding: 20px 40px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .audio-init-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0,255,136,0.5);
        }

        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar terminal controls"
                "sidebar terminal controls";
            grid-template-columns: 280px 1fr 380px;
            grid-template-rows: 70px 1fr;
            height: 100vh;
        }

        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: 250px 1fr 320px;
            }
        }

        @media (max-width: 1024px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "terminal controls"
                    "sidebar sidebar";
                grid-template-columns: 1fr 350px;
                grid-template-rows: 70px 1fr 200px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "terminal"
                    "controls"
                    "sidebar";
                grid-template-columns: 1fr;
                grid-template-rows: 70px 1fr auto auto;
                height: auto;
            }
        }

        .header {
            grid-area: header;
            background: rgba(0,0,0,0.95);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 25px;
            backdrop-filter: blur(20px);
            box-shadow: 0 1px 20px rgba(0,0,0,0.3);
        }

        .logo {
            font-size: 1.4rem;
            font-weight: 700;
            color: #00ff88;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .version-tag {
            font-size: 0.7rem;
            font-weight: 500;
            color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-btn {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .header-btn:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .sidebar {
            grid-area: sidebar;
            background: rgba(0,0,0,0.9);
            border-right: 1px solid rgba(255,255,255,0.1);
            padding: 25px;
            backdrop-filter: blur(20px);
            overflow-y: auto;
        }

        .sidebar h3 {
            color: #00ff88;
            margin-bottom: 16px;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            font-weight: 600;
        }

        .preset-item {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .preset-item:hover {
            background: rgba(255,255,255,0.08);
            transform: translateX(8px);
            border-color: rgba(0,255,136,0.3);
        }

        .preset-item.active {
            background: rgba(0,255,136,0.15);
            border-color: #00ff88;
        }

        .terminal-container {
            grid-area: terminal;
            padding: 25px;
            display: flex;
            flex-direction: column;
        }

        .terminal {
            flex: 1;
            background: rgba(0,0,0,0.95);
            border-radius: 16px;
            padding: 28px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 40px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            display: flex;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
        }

        .terminal-title {
            color: #00ff88;
            font-weight: 600;
            flex: 1;
            font-size: 1.1rem;
        }

        .terminal-stats {
            display: flex;
            gap: 20px;
            font-size: 0.85rem;
            opacity: 0.8;
            font-weight: 500;
        }

        .output {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 24px;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            min-height: 320px;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
        }

        .output::-webkit-scrollbar { width: 8px; }
        .output::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        .output::-webkit-scrollbar-thumb { background: rgba(0,255,136,0.4); border-radius: 4px; }

        .input-section { display: flex; gap: 12px; align-items: center; }
        .prompt { color: #00ff88; font-weight: 600; white-space: nowrap; font-size: 1rem; }

        .command-input {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
            font-size: 14px;
            outline: none;
            padding: 14px 18px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .command-input:focus {
            border-color: #00ff88;
            background: rgba(255,255,255,0.08);
            box-shadow: 0 0 0 2px rgba(0,255,136,0.2);
        }

        .send-btn {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            border: none;
            color: #000;
            padding: 14px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,255,136,0.4);
        }

        .controls-panel {
            grid-area: controls;
            background: rgba(0,0,0,0.9);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 25px;
            backdrop-filter: blur(20px);
            overflow-y: auto;
        }

        .control-section { margin-bottom: 28px; }

        .control-section h3 {
            color: #00ff88;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .control-btn {
            width: 100%;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff;
            padding: 14px 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-align: left;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.12);
            transform: translateX(6px);
            border-color: rgba(0,255,136,0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .mixer {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .visualizer-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            height: 120px;
            position: relative;
            overflow: hidden;
        }

        .visualizer-bars {
            display: flex;
            align-items: flex-end;
            height: 80px;
            gap: 2px;
            justify-content: space-around;
        }

        .viz-bar {
            background: linear-gradient(to top, #00ff88, #00d4ff, #ff6b9d);
            width: 3px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .error { color: #ff4757; }
        .success { color: #00ff88; }
        .info { color: #00d4ff; }
        .warning { color: #ffa502; }
        .ai { color: #ff6b9d; }
        .system { color: #7bed9f; }

        .api-key-setup {
            background: rgba(255,165,0,0.1);
            border: 1px solid #ffa502;
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 24px;
        }

        .api-input {
            width: 100%;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            color: #fff;
            margin: 12px 0;
            font-size: 0.9rem;
        }

        .performance-warning {
            background: rgba(255,165,0,0.1);
            border: 1px solid #ffa502;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            display: none;
        }
        .performance-warning.show { display: block; }

        .player-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
        }
        .player-indicator {
            display: inline-block; width: 8px; height: 8px;
            background: #00ff88; border-radius: 50%;
            margin-right: 8px;
        }

        /* --- HELP MODAL STYLES --- */
        .help-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(15px);
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .help-modal-content {
            background: #1e1e2d;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            animation: slideIn 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
        }
        
        @keyframes slideIn {
            from { transform: translateY(50px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .help-modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-modal-header h2 {
            color: #00ff88;
            font-size: 1.5rem;
        }

        .close-help-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 35px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .close-help-btn:hover {
            background: #ff4757;
            transform: rotate(90deg);
        }

        .help-modal-body {
            padding: 30px;
            overflow-y: auto;
            line-height: 1.7;
        }

        .help-modal-body h3 {
            color: #00d4ff;
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            padding-bottom: 5px;
        }
        .help-modal-body h3:first-child {
            margin-top: 0;
        }

        .help-modal-body p {
            margin-bottom: 15px;
            opacity: 0.9;
        }
        
        .help-modal-body code {
            background: rgba(0,0,0,0.5);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            color: #ff6b9d;
        }
        
        .help-modal-body ul {
            list-style-type: none;
            padding-left: 0;
        }
        .help-modal-body li {
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #00d4ff;
        }
    </style>
</head>
<body>
    <div class="audio-init-overlay" id="audioInitOverlay">
        <div class="audio-init-content">
            <h2 style="color: #00ff88; margin-bottom: 20px;">üéµ AI Music Co-pilot</h2>
            <p style="margin-bottom: 20px; opacity: 0.9;">
                Enable the professional audio engine for the best experience.
            </p>
            <button class="audio-init-btn" onclick="initializeAudio()">
                üöÄ Enable Professional Audio
            </button>
        </div>
    </div>
    
    <div class="help-modal-overlay" id="helpModal">
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h2>üìñ Co-pilot Manual</h2>
                <button class="close-help-btn" onclick="toggleHelpModal()">&times;</button>
            </div>
            <div class="help-modal-body">
                <h3>üéµ AI Music Co-pilot v6.0 - Complete Guide</h3>
                <p>Your advanced AI partner with musical intelligence, genre expertise, and learning capabilities. This system understands music theory, detects your mood, and adapts to your creative style.</p>
                
                <h3>üöÄ Quick Start: Building Your First Track</h3>
                <ol>
                    <li><strong>Start with Rhythm:</strong> <code>"create a driving techno beat"</code> or <code>"give me a groovy house rhythm"</code></li>
                    <li><strong>Add Bass Foundation:</strong> <code>"add a pumping bassline with sidechain"</code> - AI detects genre and suggests compatible bass</li>
                    <li><strong>Layer Harmony:</strong> <code>"add some dark pads in minor"</code> or <code>"create uplifting major chords"</code></li>
                    <li><strong>Build Energy:</strong> <code>"make it more aggressive"</code> or <code>"add a screaming lead"</code></li>
                </ol>

                <h3>üéõÔ∏è Advanced Co-pilot Features</h3>
                <ul>
                    <li><strong>üéöÔ∏è Mix Suggestions:</strong> Real-time mixing advice based on your track analysis</li>
                    <li><strong>üìù Arrangement Ideas:</strong> Timeline-based structural suggestions for your track</li>
                    <li><strong>üé® Style Transfer:</strong> Transform your track between genres while keeping core elements</li>
                    <li><strong>‚ö° Energy Control:</strong> "Pump it up" or "make it chill" with intelligent adaptation</li>
                    <li><strong>üîÑ Evolution Commands:</strong> "Evolve the drums" or "vary the bassline" for dynamic changes</li>
                    <li><strong>üß† Learning System:</strong> AI remembers your preferences and suggests personalized ideas</li>
                </ul>

                <h3>üé≠ Voice Commands & Mood Detection</h3>
                <p>The AI understands natural language and detects your creative mood:</p>
                <ul>
                    <li><strong>Energy Commands:</strong> "Make it more aggressive", "Pump it up", "Add some drive"</li>
                    <li><strong>Chill Commands:</strong> "Make it chill", "Tone it down", "Add some ambient vibes"</li>
                    <li><strong>Style Commands:</strong> "Daft Punk style", "Add some trance elements", "Make it more underground"</li>
                    <li><strong>Smart Effects:</strong> "Add pumping", "With long reverb", "Make it wobble"</li>
                </ul>

                <h3>ü•Å Precision Drum Programming</h3>
                <p>Use pattern notation for exact control: <code>play drums "[pattern]"</code></p>
                <ul>
                    <li><code>x</code> - Kick Drum (4/4 foundation)</li>
                    <li><code>o</code> - Snare/Clap (backbeat)</li>
                    <li><code>h</code> - Closed Hi-Hat (rhythm detail)</li>
                    <li><code>H</code> - Open Hi-Hat (groove accent)</li>
                    <li><code>c</code> - Clap (percussive punch)</li>
                    <li><code>t</code> - Tom (fills and transitions)</li>
                    <li><code>-</code> - Rest (space and breathing)</li>
                </ul>
                <p><strong>Pro Examples:</strong><br>
                House: <code>"x-H-o-H-"</code><br>
                Techno: <code>"x-x-x-x-"</code><br>
                DnB: <code>"x-t-o-t-"</code></p>

                <h3>üéπ Musical Intelligence & Theory</h3>
                <p>The AI understands music theory and suggests harmonically correct progressions:</p>
                <ul>
                    <li><strong>Smart Chord Progressions:</strong> AI suggests I-V-vi-IV and other classic progressions</li>
                    <li><strong>Key Detection:</strong> Automatically detects your track's key and scale</li>
                    <li><strong>Genre Patterns:</strong> Knows characteristic patterns for House, Techno, Ambient, DnB, Trance</li>
                    <li><strong>Harmonic Compatibility:</strong> New elements automatically complement existing layers</li>
                </ul>

                <h3>üéöÔ∏è Enhanced Effects & Production</h3>
                <p>Add professional effects with natural language:</p>
                <ul>
                    <li><code>"with sidechain"</code> - Pumping effect synchronized to kick</li>
                    <li><code>"with long reverb"</code> - Spacious ambient tail</li>
                    <li><code>"with filter sweep"</code> - Dynamic frequency modulation</li>
                    <li><code>"with delay"</code> - Rhythmic echo effects</li>
                    <li><code>"make it wobble"</code> - LFO modulation for bass</li>
                </ul>

                <h3>üìä Learning & Memory System</h3>
                <ul>
                    <li><strong>üíæ Save Templates:</strong> Preserve your favorite arrangements for later use</li>
                    <li><strong>üìà Learning Stats:</strong> View your genre preferences and creative patterns</li>
                    <li><strong>üéØ AI Suggestions:</strong> Get personalized ideas based on your history</li>
                    <li><strong>üîÑ Auto-Save:</strong> System automatically learns from successful sessions</li>
                </ul>

                <h3>üé™ Pro Tips for Advanced Use</h3>
                <ul>
                    <li><strong>Layer Gradually:</strong> Start simple, let AI suggest the next layer</li>
                    <li><strong>Use Mood Words:</strong> "Dark", "uplifting", "aggressive", "dreamy" guide AI suggestions</li>
                    <li><strong>Experiment with Evolution:</strong> Use "evolve" commands to create variations</li>
                    <li><strong>Trust the AI:</strong> It understands music theory - let it guide harmonic choices</li>
                    <li><strong>Combine Commands:</strong> "Add a dark techno bassline with heavy sidechain compression"</li>
                </ul>

                <p><strong>Remember:</strong> The AI learns from every session and adapts to your creative style. The more you use it, the better it becomes at predicting your preferences!</p>
            </div>
        </div>
    </div>

    <div class="app-container">
        <header class="header">
            <a href="index.html" class="logo">
                üéµ AI Music Co-pilot <span class="version-tag">Evolution v5.4</span>
            </a>
            <div class="header-controls">
                <div class="status-indicator">
                    <span id="audioStatusText">Audio Disabled</span>
                </div>
                <div class="status-indicator">
                    <span id="backendStatusText">üîå Backend: Checking...</span>
                </div>
                <button class="header-btn" onclick="toggleHelpModal()">üìñ Help</button>
                <button class="header-btn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
                <button class="header-btn" onclick="shareProject()">üîó Share</button>
            </div>
        </header>

        <aside class="sidebar">
            <div class="performance-warning" id="performanceWarning">
                ‚ö†Ô∏è <strong>Mobile Device Detected:</strong> Performance optimized.
            </div>

            <div class="api-key-setup" id="apiSetup">
                <h3>üîë AI Setup</h3>
                <p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 8px;">Enable AI music generation</p>
                <input type="password" class="api-input" id="apiKeyInput" placeholder="Enter your Google AI API Key">
                <button class="control-btn" style="background: rgba(0,255,136,0.2); border-color: #00ff88;" onclick="setupAPI()">
                    Activate AI
                </button>
            </div>

            <div class="preset-list">
                <h3>üéº Studio Presets v6.0</h3>
                <div class="preset-item" onclick="loadPreset('progressive-house')"><strong>üåÖ Progressive House</strong><br><small style="opacity: 0.7;">Uplifting journey with evolving layers</small></div>
                <div class="preset-item" onclick="loadPreset('dark-techno')"><strong>üñ§ Dark Techno</strong><br><small style="opacity: 0.7;">Industrial underground with heavy sidechain</small></div>
                <div class="preset-item" onclick="loadPreset('future-bass')"><strong>üí´ Future Bass</strong><br><small style="opacity: 0.7;">Modern drops with emotional chords</small></div>
                <div class="preset-item" onclick="loadPreset('minimal-deep')"><strong>üåä Minimal Deep</strong><br><small style="opacity: 0.7;">Hypnotic groove with subtle textures</small></div>
                <div class="preset-item" onclick="loadPreset('euphoric-trance')"><strong>‚ú® Euphoric Trance</strong><br><small style="opacity: 0.7;">Soaring leads with pumping energy</small></div>
                <div class="preset-item" onclick="loadPreset('ambient-cinematic')"><strong>üé¨ Cinematic Ambient</strong><br><small style="opacity: 0.7;">Atmospheric soundscape with movement</small></div>
            </div>
        </aside>

        <main class="terminal-container">
            <div class="terminal">
                <div class="terminal-header">
                    <div class="terminal-title">Evolution Audio Engine v5.4</div>
                    <div class="terminal-stats">
                        <span>BPM: <span id="bpmDisplay">120</span></span>
                        <span>‚è±Ô∏è <span id="timeDisplay">00:00</span></span>
                        <span>Active: <span id="activeCount">0</span></span>
                    </div>
                </div>
                
                <div class="output" id="output"></div>
                
                <div class="input-section">
                    <div class="prompt">üéß ></div>
                    <input type="text" class="command-input" id="commandInput" placeholder="Describe your musical vision..." autofocus>
                    <button class="send-btn" id="sendBtn" onclick="processCommand()">Create</button>
                </div>
            </div>
        </main>

        <aside class="controls-panel">
            <div class="visualizer-container">
                <div class="visualizer-bars" id="visualizerBars"></div>
            </div>

            <div class="control-section">
                <h3>üéöÔ∏è Master Section</h3>
                <div class="mixer">
                    <div style="display: flex; align-items: center; margin-bottom: 14px;">
                        <div style="width: 35px; font-size: 0.8rem; color: #00ff88;">VOL</div>
                        <input type="range" style="flex: 1; margin: 0 12px;" id="masterVolume" min="0" max="1" step="0.02" value="0.7" oninput="setMasterVolume(this.value)">
                        <div style="width: 40px; font-size: 0.8rem; text-align: right;" id="volumeDisplay">70%</div>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <div style="width: 35px; font-size: 0.8rem; color: #00ff88;">BPM</div>
                        <input type="range" style="flex: 1; margin: 0 12px;" id="masterTempo" min="80" max="180" value="120" oninput="setTempo(this.value)">
                        <div style="width: 40px; font-size: 0.8rem; text-align: right;" id="tempoDisplay">120</div>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>‚ú® AI Co-pilot</h3>
                <button class="control-btn" id="analyzeBtn" onclick="analyzeTrack()">üß† ‚ú® Analyze Track</button>
                <button class="control-btn" id="nameTrackBtn" onclick="nameMyTrack()">üè∑Ô∏è ‚ú® Name My Track</button>
            </div>

            <div class="control-section">
                <h3>‚èØÔ∏è Transport & State</h3>
                <button class="control-btn" style="background: rgba(255,71,87,0.2); border-color: #ff4757;" onclick="stopAllSounds()">‚èπÔ∏è Stop All</button>
                <button class="control-btn" onclick="showCurrentState()">üéº View AI State</button>
                <button class="control-btn" onclick="clearTerminal()">üßπ Clear Log</button>
            </div>

            <div class="control-section">
                <h3>üéµ Live Players</h3>
                <div class="mixer" id="playersState">
                    <div class="info" style="text-align: center; opacity: 0.6; font-size: 0.85rem;">No active players</div>
                </div>
            </div>
        </aside>
    </div>

    <script>
    // ===== EVOLUTION AUDIO ENGINE v6.3 (AImCo_evo2) =====
    // MAJOR UPGRADE: Implemented a new AI prompting strategy.
    // The AI now returns a structured JSON object containing both a 'command' for execution
    // and a detailed 'metadata' object for state management, inspired by the FoxDot version.
    // This makes our state infinitely richer and our code cleaner.

    // AdaugƒÉ asta la √Ænceputul script-ului
    let sampleBuffers = {}; // Va stoca bufferele audio decodate

    async function loadSample(url, name) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            sampleBuffers[name] = audioBuffer;
            console.log(`‚úÖ Sample '${name}' √ÆncƒÉrcat »ôi decodat.`);
        } catch (error) {
            console.error(`‚ùå Eroare la √ÆncƒÉrcarea sample-ului '${name}':`, error);
        }
    }

    // √éncƒÉrcƒÉm c√¢teva sample-uri la pornire (dupƒÉ ini»õializarea audio)
    // Va trebui sƒÉ gƒÉzduie»ôti aceste fi»ôiere undeva.
    // await initializeAudio();
    // loadSample('path/to/kick.wav', 'kick');
    // loadSample('path/to/snare.wav', 'snare');
    // loadSample('path/to/hihat.wav', 'hihat');

    let audioContext = null;
    let masterGain = null;
    // ... (rest of the initial variables are the same)
    let sidechainGain = null;
    let analyser = null;
    let audioInitialized = false;
    let isMobileDevice = false;
    let maxConcurrentOscillators = 24;
    
    let currentTempo = 120;
    let apiKey = '';
    let startTime = Date.now();
    let musicState = {}; 
    
    let activePlayers = {}; //-- NEW: This will store the audio nodes for live control.
    
    //-- FIXED: Complete list of all valid instrument types including 'hihats' and 'drums'
    const PLAYABLE_INSTRUMENT_TYPES = [
        'drum', 'drums', 'bass', 'lead', 'pads', 'hi-hat', 'hihats', 'kick', 'snare', 'clap', 'tom', 
        'cymbal/crash', 'ride', 'percussion', 'acid-bass', 'arpeggiated-synth', 
        'string-synth', 'pluck-synth', 'white-noise/sweep', 'chords', 'vocal-chop/sample'
    ];

    // --- CORE AUDIO & COMPONENTS (No changes here) ---
    // (detectMobileDevice, initializeAudio, ensureAudioContext, BulletproofADSR, OscillatorPool, PrecisionScheduler, createBulletproofOscillator, createBulletproofDrum all remain the same)
    
    //-- NEW: A helper function to translate musical notation into MIDI numbers.
    function noteToMidi(noteName) {
        const noteMap = { 'c': 0, 'c#': 1, 'db': 1, 'd': 2, 'd#': 3, 'eb': 3, 'e': 4, 'f': 5, 'f#': 6, 'gb': 6, 'g': 7, 'g#': 8, 'ab': 8, 'a': 9, 'a#': 10, 'bb': 10, 'b': 11 };
        const match = noteName.toLowerCase().match(/^([a-g][#b]?)-?(\d+)/);

        if (!match) return null; // Return null if the format is invalid

        const note = noteMap[match[1]];
        const octave = parseInt(match[2], 10);

        // Our engine's "0" is C4. MIDI standard "0" is C-1. We need to adjust.
        // MIDI for C4 is 60. So we'll calculate the MIDI note and then subtract 60.
        const midiNote = 12 * (octave + 1) + note;
        return midiNote - 60; // Adjust to our C4=0 standard
    }

    //-- UPDATED: Enhanced function to control channel strip parameters
    function setPlayerVolume(player, volume) { // volume is 0.0 to 1.0
        if (activePlayers[player] && activePlayers[player].gainNode) {
            const gainNode = activePlayers[player].gainNode;

            // Clamp the volume to a safe range (e.g., 0.0 to 1.5)
            const clampedVolume = Math.max(0, Math.min(1.5, volume));

            gainNode.gain.setValueAtTime(clampedVolume, audioContext.currentTime);
            addOutput(`üîä Volume for ${player.toUpperCase()} set to ${Math.round(clampedVolume * 100)}%`, 'info');
        } else {
            addOutput(`ü§î Player ${player.toUpperCase()} not found. Can't set volume.`, 'warning');
        }
    }

    //-- NEW: Function to control player panning
    function setPlayerPan(player, pan) { // pan is -1.0 (left) to 1.0 (right)
        if (activePlayers[player] && activePlayers[player].pannerNode) {
            const clampedPan = Math.max(-1, Math.min(1, pan));
            activePlayers[player].pannerNode.pan.setValueAtTime(clampedPan, audioContext.currentTime);
            const position = clampedPan < 0 ? `${Math.abs(clampedPan * 100).toFixed(0)}% Left` :
                           clampedPan > 0 ? `${(clampedPan * 100).toFixed(0)}% Right` : 'Center';
            addOutput(`üéöÔ∏è Pan for ${player.toUpperCase()} set to ${position}`, 'info');
        } else {
            addOutput(`ü§î Player ${player.toUpperCase()} not found. Can't set pan.`, 'warning');
        }
    }

    //-- NEW: Function to control player filter
    function setPlayerFilter(player, type, frequency, q = 1) {
        if (activePlayers[player] && activePlayers[player].filterNode) {
            const filter = activePlayers[player].filterNode;
            filter.type = type;
            filter.frequency.setValueAtTime(frequency, audioContext.currentTime);
            filter.Q.value = q;
            addOutput(`üéõÔ∏è Filter for ${player.toUpperCase()}: ${type} at ${frequency}Hz (Q=${q})`, 'info');
        } else {
            addOutput(`ü§î Player ${player.toUpperCase()} not found. Can't set filter.`, 'warning');
        }
    }
    
    function detectMobileDevice() {
        let isMobileDevice = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
            window.matchMedia("(max-width: 768px)").matches;
        if (isMobileDevice) {
            let maxConcurrentOscillators = 12;
            const warningElement = document.getElementById('performanceWarning');
            if (warningElement) {
                warningElement.classList.add('show');
            }
        }
        return isMobileDevice;
    }
    async function initializeAudio() {
        if (audioInitialized) return true;
        try {
            document.getElementById('audioInitOverlay').style.display = 'none';
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;

            // Enhanced audio context creation with better error handling
            audioContext = new AudioContextClass({
                latencyHint: isMobileDevice ? 'interactive' : 'playback',
                sampleRate: isMobileDevice ? 44100 : 48000
            });

            // Wait for user interaction if needed
            if (audioContext.state === 'suspended') {
                addOutput('üîä Resuming audio context...', 'info');
                await audioContext.resume();
            }

            // Create audio nodes with error checking
            masterGain = audioContext.createGain();
            sidechainGain = audioContext.createGain();
            analyser = audioContext.createAnalyser();

            // Configure analyser for better performance
            analyser.fftSize = isMobileDevice ? 128 : 256;
            analyser.smoothingTimeConstant = 0.8;

            // Connect audio graph
            masterGain.connect(sidechainGain);
            sidechainGain.connect(analyser);
            analyser.connect(audioContext.destination);

            // Set initial volume
            masterGain.gain.setValueAtTime(0.7, audioContext.currentTime);
            sidechainGain.gain.setValueAtTime(1.0, audioContext.currentTime);

            audioInitialized = true;
            document.getElementById('audioStatusText').textContent = `Audio Ready (${Math.round(audioContext.sampleRate/1000)}kHz)`;
            addOutput('üéµ Evolution Audio Engine Initialized!', 'system');
            addOutput(`üîä Sample Rate: ${audioContext.sampleRate}Hz | Latency: ${Math.round(audioContext.baseLatency * 1000)}ms`, 'info');

            initVisualizer();
            return true;
        } catch (error) {
            document.getElementById('audioStatusText').textContent = 'Audio Failed';
            addOutput(`‚ùå Audio initialization failed: ${error.message}`, 'error');
            console.error('Audio initialization error:', error);
            return false;
        }
    }
    async function ensureAudioContext() {
        if (!audioInitialized) { return await initializeAudio(); }
        if (audioContext.state === 'suspended') await audioContext.resume();
        return true;
    }
    class BulletproofADSR {
        constructor(audioContext, gainNode) { this.context = audioContext; this.gain = gainNode; }
        trigger(attack = 0.01, decay = 0.3, sustain = 0.7, release = 0.5, duration = 1) {
            const now = this.context.currentTime;
            const sustainTime = Math.max(0, duration - attack - decay - release);
            this.gain.gain.cancelScheduledValues(now); this.gain.gain.setValueAtTime(0.001, now);
            this.gain.gain.linearRampToValueAtTime(1, now + attack); this.gain.gain.linearRampToValueAtTime(sustain, now + attack + decay);
            this.gain.gain.setValueAtTime(sustain, now + attack + decay + sustainTime);
            this.gain.gain.linearRampToValueAtTime(0.001, now + attack + decay + sustainTime + release);
        }
    }
    class OscillatorPool {
        constructor() {
            this.activeNodes = new Set();
            this.statsInterval = null;
            this.startStatsMonitoring();
        }

        startStatsMonitoring() {
            // Monitor pool usage every 5 seconds
            this.statsInterval = setInterval(() => {
                this.cleanup();
                if (this.activeNodes.size > maxConcurrentOscillators * 0.8) {
                    addOutput(`‚ö†Ô∏è High oscillator usage: ${this.activeNodes.size}/${maxConcurrentOscillators}`, 'warning');
                }
            }, 5000);
        }

        createNode(type) {
            this.cleanup();
            if (this.activeNodes.size >= maxConcurrentOscillators) {
                addOutput(`‚ö†Ô∏è Audio limit reached (${this.activeNodes.size}/${maxConcurrentOscillators}).`, 'warning');
                return null;
            }

            let node;
            try {
                if (type === 'osc' || type === 'lfo') {
                    node = audioContext.createOscillator();
                } else if (type === 'noise') {
                    const bufferSize = Math.min(audioContext.sampleRate * 0.5, 44100); // Limit buffer size
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    node = audioContext.createBufferSource();
                    node.buffer = buffer;
                    node.loop = false;
                } else {
                    throw new Error(`Unknown node type: ${type}`);
                }

                const gain = audioContext.createGain();
                const nodeGroup = {
                    node,
                    gain,
                    finished: false,
                    type,
                    createdAt: Date.now()
                };

                this.activeNodes.add(nodeGroup);

                // Enhanced cleanup handling
                const onEnded = () => {
                    nodeGroup.finished = true;
                    setTimeout(() => this.cleanup(), 100); // Delayed cleanup
                };

                node.onended = onEnded;
                if (node.addEventListener) {
                    node.addEventListener('ended', onEnded);
                }

                return nodeGroup;
            } catch (error) {
                console.error('Error creating audio node:', error);
                addOutput(`‚ùå Failed to create ${type} node: ${error.message}`, 'error');
                return null;
            }
        }

        cleanup() {
            const initialSize = this.activeNodes.size;
            for (const nodeGroup of this.activeNodes) {
                if (nodeGroup.finished || (Date.now() - nodeGroup.createdAt > 300000)) { // 5min timeout
                    try {
                        nodeGroup.node.disconnect();
                        nodeGroup.gain.disconnect();
                    } catch (e) {
                        console.warn('Cleanup disconnect error:', e);
                    }
                    this.activeNodes.delete(nodeGroup);
                }
            }
            if (initialSize > 0 && this.activeNodes.size < initialSize) {
                console.log(`üßπ Cleaned up ${initialSize - this.activeNodes.size} audio nodes`);
            }
        }

        stopAll() {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            let stoppedCount = 0;

            for (const nodeGroup of this.activeNodes) {
                try {
                    nodeGroup.gain.gain.cancelScheduledValues(now);
                    nodeGroup.gain.gain.setValueAtTime(nodeGroup.gain.gain.value, now);
                    nodeGroup.gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
                    if(nodeGroup.node.stop) {
                        nodeGroup.node.stop(now + 0.1);
                        stoppedCount++;
                    }
                } catch (e) {
                    console.warn('Stop error:', e);
                }
            }
            addOutput(`üõë Stopped ${stoppedCount} audio nodes`, 'info');
        }

        destroy() {
            if (this.statsInterval) {
                clearInterval(this.statsInterval);
                this.statsInterval = null;
            }
            this.stopAll();
            this.activeNodes.clear();
        }
    }
    const oscillatorPool = new OscillatorPool();
    class PrecisionScheduler {
        constructor() { this.scheduledEvents = new Map(); this.nextEventId = 0; }
        schedule(callback, delayInSeconds) { const id = this.nextEventId++; const timeoutId = setTimeout(() => { callback(); this.scheduledEvents.delete(id); }, delayInSeconds * 1000); this.scheduledEvents.set(id, { timeoutId }); return id; }
        cancel(eventId) { const event = this.scheduledEvents.get(eventId); if (event) { clearTimeout(event.timeoutId); this.scheduledEvents.delete(eventId); } }
        cancelAll() { for (const event of this.scheduledEvents.values()) { clearTimeout(event.timeoutId); } this.scheduledEvents.clear(); }
    }
    const scheduler = new PrecisionScheduler();
    // REMOVED: Incomplete oscillator function - using the complete version below

    // --- EVOLVED AI & COMMAND PROCESSING v6.3 (AImCo_evo2) ---

    function getMusicStateSummary() {
        const activePlayers = Object.entries(musicState)
            .filter(([_, data]) => data.status === 'playing')
            .reduce((obj, [key, val]) => {
                const { nextEventId, ...rest } = val; 
                obj[key] = rest;
                return obj;
            }, {});
        
        if (Object.keys(activePlayers).length === 0) return "The musical canvas is empty.";
        return JSON.stringify(activePlayers, null, 2);
    }

    // --- ENHANCED AI BACKEND CONNECTION ---
    // Try Flask backend first, fallback to direct Gemini API
    async function callAIBackend(prompt, currentStateSummary) {
        try {
            // Try Flask backend first (from Aimuco.py)
            const backendResponse = await fetch('http://localhost:5001/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: prompt })
            });

            if (backendResponse.ok) {
                const data = await backendResponse.json();
                if (data.success) {
                    addOutput('üéµ AI Backend connected! Using FoxDot engine.', 'ai');
                    // Convert FoxDot response to our format
                    return [{
                        command: data.code,
                        metadata: data.metadata
                    }];
                }
            }
        } catch (error) {
            console.log('Flask backend not available, using direct API:', error.message);
        }

        // Fallback to direct Gemini API
        return await callGeminiAPI(prompt, currentStateSummary);
    }

    //-- MODIFIED: The AI 'brain' is replaced with our new hybrid prompt.
    async function callGeminiAPI(prompt, currentStateSummary) {
        if (!apiKey) {
            addOutput('‚ùå Please configure your API key in the sidebar.', 'error');
            return null;
        }
        addOutput('ü§ñ AI producer is analyzing the track...', 'ai');

        const systemInstruction = `You are an elite electronic music producer AI. You will receive a user's idea and the current musical state.
Your entire response MUST be a single, valid JSON object with a "layers" key.
"layers" must be an array of objects, where each object has a "command" string and a "metadata" object.

--- METADATA REQUIREMENTS ---
- For ALL layers (drums, bass, etc.), include "player", "type", and any other relevant musical info.
- MELODIC types ("bass", "lead", "pads"): include "preset", "notes" (as an array of numbers).
- DRUM type ("drum"): include "pattern" (as a rhythm string).
- STOP actions: The command should be "stop [player]" and metadata must include "player" and "action: 'stop'".
- EFFECTS: If the user mentions effects, include an "effects" object in the metadata (e.g., {"sidechain": true}).

--- EXAMPLE WORKFLOW ---

1. User Request: "a simple house beat"
   Current State: "The musical canvas is empty."
   Your JSON Response:
   {
     "layers": [
       {
         "command": "play drums 'x-H-o-H-'",
         "metadata": { "player": "d1", "type": "drum", "pattern": "x-H-o-H-c-" }
       }
     ]
   }

2. User Request: "add some dreamy pads"
   Current State: { "d1": { "type": "drum", "pattern": "x-H-o-H-" } }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "play pads [E2, A2, F2, E2] as sine-pad with pumping and long reverb",
         "metadata": {
           "player": "p1", "type": "pads", "preset": "sine-pad",
           "notes": [E2, A2, F2, E2], "effects": { "sidechain": true, "reverb": "long" }
         }
       }
     ]
   }

3. User Request: "stop the drums"
   Current State: { "d1": ..., "p1": ... }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "stop d1",
         "metadata": { "player": "d1", "action": "stop" }
       }
     ]
   }

4.  User Request: "set tempo to 90 bpm"
    Current State: { ... }
    Your JSON Response:
    {
      "layers": [
        {
          "command": "set tempo 90",
          "metadata": { "action": "set_tempo", "value": 90 }
        }
    ]
}

5. User Request: "bass volume 50%"
   Current State: { "b1": { "type": "bass", ... } }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "set volume b1 50%",
         "metadata": { "action": "set_volume", "player": "b1", "value": "50" }
       }
     ]
   }

6. User Request: "add a hard kick with amp 0.9"
   Current State: { ... }
   Your JSON Response:
   {
     "layers": [
       {
         "command": "play kick 'x---x---' with amp 0.9",
         "metadata": {
           "player": "d2",
           "type": "kick",
           "pattern": "x---x---",
           "effects": { "amp": 0.9 }
         }
       }
     ]
   }

User Request: "${prompt}"
Current Musical State: ${currentStateSummary}`;


        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: systemInstruction }] }],
                    generationConfig: { temperature: 0.9, maxOutputTokens: 800, responseMimeType: "application/json" }
                })
            });

            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();
            const text = data.candidates[0].content.parts[0].text;
            const result = JSON.parse(text);

            if (result.layers && Array.isArray(result.layers)) {
                addOutput(`üéµ AI generated ${result.layers.length} new musical layer(s).`, 'ai');
                return result.layers;
            }
            throw new Error("Invalid format from AI: 'layers' array not found.");
        } catch (error) {
            addOutput(`‚ùå AI API Error: ${error.message}`, 'error');
            console.error(error); return null;
        }
    }
    
    //-- MODIFIED: This function now handles the new, richer JSON structure and backend connection.
    async function executeCommands(prompt) {
        const currentStateSummary = getMusicStateSummary();
        const commandLayers = await callAIBackend(prompt, currentStateSummary);

        if (commandLayers && commandLayers.length > 0) {
            for (const [index, layer] of commandLayers.entries()) {
                setTimeout(() => {
                    const { command, metadata } = layer;
                    if (!command || !metadata) {
                        addOutput(`ü§î AI response layer was malformed.`, 'warning');
                        return;
                    }

                    // Assign a player name if the AI didn't.
                    if (!metadata.player && metadata.type) {
                        metadata.player = getNextPlayer(metadata.type.charAt(0));
                    }

                    executeDirectCommand(command, metadata);
                    updateMusicState(metadata.player, metadata);

                }, index * 200);
            }
        }
    }
    
    //-- MODIFIED: We no longer need to parse commands for metadata.
    // The AI gives it to us directly. This function is much simpler.
    //-- MODIFIED: This function is now more robust and won't crash on incomplete metadata.
    //-- MODIFIED: This function can now understand tempo changes.
    
    function executeDirectCommand(command, metadata) {
        try {
            addOutput(`‚úÖ Executing: ${command}`, 'success');

            // --- PRIORITY ACTIONS ---
            // Check for specific actions first, as they don't have an instrument 'type'.
            if (metadata.action === 'stop') {
                stopPlayer(metadata.player);
                return;
            } 
            else if (metadata.action === 'set_tempo') {
                const tempoValue = parseInt(metadata.value, 10);
                if (!isNaN(tempoValue)) {
                    setTempo(tempoValue);
                    document.getElementById('masterTempo').value = tempoValue;
                }
                return;
            }
            else if (metadata.action === 'set_volume') {
                const volumeValue = parseFloat(metadata.value) / 100.0;
                if (!isNaN(volumeValue)) {
                    setPlayerVolume(metadata.player, volumeValue);
                }
                return;
            }

            // --- INSTRUMENT PLAYBACK ---
            // If it's not a priority action, check if it's a playable instrument type.
            if (!metadata.type) {
                addOutput(`ü§î AI suggested a command I don't understand yet: "${command}"`, 'warning');
                return;
            }
            
            if (PLAYABLE_INSTRUMENT_TYPES.includes(metadata.type)) {
                startBulletproofPlayer(metadata.player, metadata);
            } else {
                addOutput(`ü§î Unknown metadata type: "${metadata.type}"`, 'warning');
            }

        } catch (error) {
            addOutput(`‚ùå Command execution error: ${error.message}`, 'error');
            console.error(error);
        }
    }

    //-- MODIFIED: State update is cleaner now.
    function updateMusicState(player, metadata) {
        if (!player) return;

        if (metadata.action === 'stop') {
            if (musicState[player]) {
                 musicState[player].status = 'stopped';
            }
        } else { 
            musicState[player] = { ...metadata, status: 'playing' }; 
        }
        updatePlayersDisplay();
    }

    // --- PLAYER & PATTERN LOGIC ---
    //-- MODIFIED: This function now gets the full metadata object.
    //-- MODIFIED: This function now creates the main gain node for the player.
function startBulletproofPlayer(player, config) {
    if (activePlayers[player]) {
        // DacƒÉ player-ul existƒÉ, opre»ôte scheduler-ul vechi
        scheduler.cancel(musicState[player]?.nextEventId);
    }

    // --- Noul Channel Strip ---
    const channel = {};
    channel.gainNode = audioContext.createGain();
    channel.pannerNode = audioContext.createStereoPanner();
    channel.filterNode = audioContext.createBiquadFilter(); // Pentru EQ

    // ConectƒÉm lan»õul
    channel.gainNode.connect(channel.pannerNode);
    channel.pannerNode.connect(channel.filterNode);

    // ConectƒÉm la destina»õia finalƒÉ (cu sau fƒÉrƒÉ sidechain)
    const destination = config.effects?.sidechain ? sidechainGain : masterGain;
    channel.filterNode.connect(destination);

    // SetƒÉri implicite pentru channel strip
    channel.gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
    channel.pannerNode.pan.setValueAtTime(0, audioContext.currentTime); // Centru
    channel.filterNode.type = 'allpass'; // Neutru by default
    channel.filterNode.frequency.setValueAtTime(20000, audioContext.currentTime);

    // AplicƒÉm efectele din config dacƒÉ existƒÉ
    if (config.effects) {
        if (config.effects.pan !== undefined) {
            channel.pannerNode.pan.setValueAtTime(config.effects.pan, audioContext.currentTime);
        }
        if (config.effects.filter) {
            channel.filterNode.type = config.effects.filter.type || 'lowpass';
            channel.filterNode.frequency.setValueAtTime(config.effects.filter.frequency || 5000, audioContext.currentTime);
            channel.filterNode.Q.value = config.effects.filter.q || 1;
        }
    }

    // StocƒÉm √Æntregul channel strip pentru control ulterior
    activePlayers[player] = channel;
    musicState[player] = { ...config, status: 'playing' };

    // Acum, c√¢nd creƒÉm sunetul, √Æl conectƒÉm la intrarea channel strip-ului
    // adicƒÉ la channel.gainNode
    if (config.type.match(/drum|hi-hat|kick|snare/)) {
        playBulletproofPattern(player, config.pattern, config.effects || {}, channel.gainNode);
    } else {
        const octave = config.type === 'bass' ? 3 : 4;
        playBulletproofMelody(player, config.notes, { ...config, octave }, channel.gainNode);
    }
}

    //-- UPGRADED & CORRECTED: This is the complete, final version of the synthesizer function.
    function createBulletproofOscillator(frequency, preset = 'saw-lead', duration = 1, effects = {}, destinationNode) {
        if (!ensureAudioContext()) return null;
        
        const oscGroup = oscillatorPool.createNode('osc');
        if (!oscGroup) return null; // This safety check is important!

        const { node: osc, gain: envelopeGain } = oscGroup;
        const filter = audioContext.createBiquadFilter();
        const distortion = audioContext.createWaveShaper();
        
        let waveform = 'sawtooth', amp = 0.3;
        let attack = 0.02, decay = 0.3, sustain = 0.7, release = 0.5;

        if (preset === 'sine-pad') { waveform = 'sine'; attack = 0.8; release = 1.5; amp = 0.4; }
        if (preset === 'square-bass') { waveform = 'square'; attack = 0.01; release = 0.3; amp = 0.5; }

        osc.type = waveform;
        osc.frequency.setValueAtTime(frequency, audioContext.currentTime);

        filter.type = 'lowpass';
        filter.frequency.value = 20000; 
        filter.Q.value = 1;

        if (effects.filter) {
            filter.type = effects.filter.type || 'lowpass';
            filter.frequency.setValueAtTime(effects.filter.frequency || 5000, audioContext.currentTime);
            filter.Q.value = effects.filter.q || 1;
        }

        if (effects.saturation) {
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; ++i) {
                const x = i * 2 / 255 - 1;
                curve[i] = (Math.PI + effects.saturation) * x / (Math.PI + effects.saturation * Math.abs(x));
            }
            distortion.curve = curve;
            osc.connect(distortion);
            distortion.connect(filter);
        } else {
            osc.connect(filter);
        }
        
        const stopTime = audioContext.currentTime + duration + release + 0.5;
        
        if (effects.lfo && effects.lfo.target === 'filter') {
            const lfoGroup = oscillatorPool.createNode('lfo');
            if (lfoGroup) {
                const { node: lfo, gain: lfoGain } = lfoGroup;
                lfo.type = 'sine';
                lfo.frequency.value = effects.lfo.rate || 4;
                lfoGain.gain.value = effects.lfo.amount || 100;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();
                lfo.stop(stopTime);
            }
        }

        const envelope = new BulletproofADSR(audioContext, envelopeGain);
        filter.connect(envelopeGain);
        
        // This is the corrected routing logic for volume control
        envelopeGain.connect(destinationNode); 
        
        const finalAmp = effects.amp || amp;
        // We trigger the envelope on its own gain, not the player's main gain.
        envelope.trigger(attack, decay, sustain, release, duration);
        
        osc.start();
        osc.stop(stopTime);
    }
    // We also need to slightly modify the drum and pattern functions to pass the destinationNode down.
    function playBulletproofPattern(player, pattern, effects, playerGain) {
        // ...
        function scheduleNextBeat() {
            // ...
            if (char !== '-' && char !== ' ') createBulletproofDrum(char, effects, playerGain);
            // ...
        }
        scheduleNextBeat();
    }
    // Versiune √ÆmbunƒÉtƒÉ»õitƒÉ a func»õiei - PRIORITATE SAMPLE-URI
    function createBulletproofDrum(type, effects = {}, destinationNode = masterGain) {
        if (!ensureAudioContext()) return;
        const now = audioContext.currentTime;
        const amp = effects.amp || 1.0;

        let sampleName = '';
        if (type === 'kick' || type === 'x') sampleName = 'kick';
        if (type === 'snare' || type === 'o') sampleName = 'snare';
        if (type === 'hihat' || type === 'h' || type === '.') sampleName = 'hihat';
        if (type === 'open-hihat' || type === 'H') sampleName = 'open-hihat';
        if (type === 'clap' || type === 'c') sampleName = 'clap';
        if (type === 'tom' || type === 't') sampleName = 'tom';

        // PRIORITATE: Folose»ôte sample dacƒÉ existƒÉ
        if (sampleName && sampleBuffers[sampleName]) {
            const source = audioContext.createBufferSource();
            source.buffer = sampleBuffers[sampleName];

            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(amp, now);

            source.connect(gainNode);
            gainNode.connect(destinationNode);
            source.start(now);

            // Sidechain-ul poate rƒÉm√¢ne aici, func»õioneazƒÉ la fel
            if ((type === 'kick' || type === 'x') && sidechainGain && effects.sidechain) {
                sidechainGain.gain.cancelScheduledValues(now);
                sidechainGain.gain.setValueAtTime(sidechainGain.gain.value, now);
                sidechainGain.gain.linearRampToValueAtTime(0.3, now + 0.01);
                sidechainGain.gain.linearRampToValueAtTime(1.0, now + 0.25);
            }
        } else {
            // FALLBACK: DacƒÉ sample-ul nu existƒÉ, folose»ôte sinteza veche
            console.warn(`Sample-ul pentru '${type}' nu a fost gƒÉsit. Se folose»ôte sinteza.`);

            if (type === 'kick' || type === 'x') {
                const oscGroup = oscillatorPool.createNode('osc');
                if(!oscGroup) return;
                const { node: osc, gain } = oscGroup;
                osc.type = 'sine';

                gain.gain.setValueAtTime(1 * amp, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);

                osc.connect(gain);
                gain.connect(destinationNode);
                osc.start(now);
                osc.stop(now + 0.2);

                // Sidechain effect
                if (sidechainGain && effects.sidechain) {
                    sidechainGain.gain.cancelScheduledValues(now);
                    sidechainGain.gain.setValueAtTime(sidechainGain.gain.value, now);
                    sidechainGain.gain.linearRampToValueAtTime(0.3, now + 0.01);
                    sidechainGain.gain.linearRampToValueAtTime(1.0, now + 0.25);
                }
            } else if (type === 'snare' || type === 'o') {
                const noiseGroup = oscillatorPool.createNode('noise');
                const oscGroup = oscillatorPool.createNode('osc');
                if(!noiseGroup || !oscGroup) return;

                const { node: noise, gain: noiseGain } = noiseGroup;
                const { node: osc, gain: oscGain } = oscGroup;
                const filter = audioContext.createBiquadFilter();

                filter.type = 'highpass';
                filter.frequency.value = 1500;
                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(destinationNode);

                osc.type = 'triangle';
                osc.frequency.value = 180;
                osc.connect(oscGain);
                oscGain.connect(destinationNode);

                noiseGain.gain.setValueAtTime(0.8 * amp, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                oscGain.gain.setValueAtTime(0.7 * amp, now);
                oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                noise.start(now);
                noise.stop(now + 0.2);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hihat' || type === 'h' || type === '.') {
                const noiseGroup = oscillatorPool.createNode('noise');
                if(!noiseGroup) return;
                const { node: noise, gain } = noiseGroup;
                const filter = audioContext.createBiquadFilter();

                filter.type = 'highpass';
                filter.frequency.value = 8000;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(destinationNode);

                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                noise.start(now);
                noise.stop(now + 0.1);
            } else if (type === 'open-hihat' || type === 'H') {
                const noiseGroup = oscillatorPool.createNode('noise');
                if(!noiseGroup) return;
                const { node: noise, gain } = noiseGroup;
                const filter = audioContext.createBiquadFilter();

                filter.type = 'highpass';
                filter.frequency.value = 7000;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(destinationNode);

                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                noise.start(now);
                noise.stop(now + 0.5);
            } else if (type === 'clap' || type === 'c') {
                const noiseGroup = oscillatorPool.createNode('noise');
                if(!noiseGroup) return;
                const { node: noise, gain } = noiseGroup;
                const filter = audioContext.createBiquadFilter();

                filter.type = 'bandpass';
                filter.frequency.value = 1500;
                filter.Q.value = 2;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(destinationNode);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(1, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                noise.start(now);
                noise.stop(now + 0.15);
            } else if (type === 'tom' || type === 't') {
                const oscGroup = oscillatorPool.createNode('osc');
                if(!oscGroup) return;
                const { node: osc, gain } = oscGroup;
                osc.type = 'sine';

                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);

                osc.connect(gain);
                gain.connect(destinationNode);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        }
    }
    function playBulletproofPattern(player, pattern, effects = {}, playerGain = masterGain) {
        const beatDuration = 60 / currentTempo / 4;
        let currentBeat = 0;
        
        function scheduleNextBeat() {
            if (!musicState[player] || musicState[player].status !== 'playing') return;
            const char = pattern[currentBeat % pattern.length];
            if (char !== '-' && char !== ' ') {
                createBulletproofDrum(char, effects, playerGain);
            }
            currentBeat++;
            musicState[player].nextEventId = scheduler.schedule(scheduleNextBeat, beatDuration);
        }
        scheduleNextBeat();
    }
    //-- MODIFIED: This function is now smarter and can handle both numbers and note names.
    function playBulletproofMelody(player, notes, config, playerGain = masterGain) {
        const noteDuration = 60 / currentTempo;
        let currentNoteIndex = 0;

        // --- NEW: Check if notes is a string and split it into an array ---
        let notesArray = notes;
        if (typeof notesArray === 'string') {
            // Split by space or hyphen
            notesArray = notesArray.split(/[\s-]+/);
        }
        // Safety check if the input was not an array or a string
        if (!Array.isArray(notesArray)) {
            addOutput(`‚ùå Invalid notes format for player ${player}. Expected an array.`, 'error');
            return;
        }
        
        function scheduleNextNote() {
            if (!musicState[player] || musicState[player].status !== 'playing') return;

            let noteValue = notesArray[currentNoteIndex % notesArray.length];

            if (typeof noteValue === 'string') {
                noteValue = noteToMidi(noteValue.trim()); // trim whitespace
            }

            if (noteValue === null || isNaN(noteValue)) {
                addOutput(`ü§î Skipping invalid note: "${notesArray[currentNoteIndex % notesArray.length]}"`, 'warning');
            } else {
                const frequency = 440 * Math.pow(2, (noteValue + 3 + (config.octave - 4) * 12) / 12);
                createBulletproofOscillator(frequency, config.preset, noteDuration * 0.8, config.effects || {}, playerGain);
            }
            
            currentNoteIndex++;
            musicState[player].nextEventId = scheduler.schedule(scheduleNextNote, noteDuration);
        }
        scheduleNextNote();
    }


    // --- UI & CONTROL FUNCTIONS ---
    async function processCommand() {
        if (!await ensureAudioContext()){ addOutput('‚ùå Audio not enabled.', 'error'); return; }
        const input = document.getElementById('commandInput');
        const commandText = input.value.trim();
        if (!commandText) return;
        addOutput(`üéß > ${commandText}`, 'info');
        input.value = '';
        
        const command = commandText.toLowerCase();
        switch(command) {
            case 'help': toggleHelpModal(); return;
            case 'clear': clearTerminal(); return;
            case 'stop all': stopAllSounds(); return;
            case 'state': showCurrentState(); return;
            default: executeCommands(commandText); // Pass original casing
        }
    }
    
    function stopPlayer(player) {
        if (musicState[player]) {
            if (musicState[player].nextEventId) scheduler.cancel(musicState[player].nextEventId);
            musicState[player].status = 'stopped';
            addOutput(`üõë Player ${player.toUpperCase()} stopped.`, 'info');
            updatePlayersDisplay();
        }
    }
    // (The rest of the UI and control functions are mostly unchanged)
    function setupAPI() { const input = document.getElementById('apiKeyInput'); apiKey = input.value.trim(); if (apiKey) { document.getElementById('apiSetup').style.display = 'none'; addOutput('‚úÖ AI features activated!', 'success'); } }
    function addOutput(text, type = 'info') {
        const output = document.getElementById('output');

        // VerificƒÉm DACƒÇ utilizatorul este deja la capƒÉtul log-ului √éNAINTE de a adƒÉuga noul element
        // AdƒÉugƒÉm o micƒÉ toleran»õƒÉ (1px) pentru a evita erori de rotunjire
        const isScrolledToBottom = output.scrollHeight - output.clientHeight <= output.scrollTop + 1;

        const div = document.createElement('div');
        div.className = type;
        // Am scos timestamp-ul pentru un aspect mai curat, dar √Æl po»õi adƒÉuga √Ænapoi dacƒÉ dore»ôti
        div.textContent = text;
        output.appendChild(div);

        // Facem scroll automat DOAR dacƒÉ era deja la capƒÉt
        if (isScrolledToBottom) {
            output.scrollTop = output.scrollHeight;
        }

        // Prevenim umplerea excesivƒÉ a memoriei
        if (output.children.length > 150) {
            output.removeChild(output.children[0]);
        }
    }
    function setMasterVolume(value) { if (masterGain) masterGain.gain.value = value; document.getElementById('volumeDisplay').textContent = `${Math.round(value * 100)}%`; }
    function setTempo(value) { currentTempo = parseInt(value); document.getElementById('tempoDisplay').textContent = value; document.getElementById('bpmDisplay').textContent = value; }
    function stopAllSounds() { 
        scheduler.cancelAll(); 
        if (audioInitialized) oscillatorPool.stopAll(); 
        musicState = {}; 
        activePlayers = {}; // Clear the active players as well
        addOutput('üõë All sounds stopped & state cleared.', 'success'); 
        updatePlayersDisplay(); 
    }
    function clearTerminal() { document.getElementById('output').innerHTML = ''; addOutput('üéµ Evolution terminal ready.', 'system'); }
    function updatePlayersDisplay() { const display = document.getElementById('playersState'); const activePlayers = Object.entries(musicState).filter(([_, data]) => data.status === 'playing'); if (activePlayers.length === 0) { display.innerHTML = '<div class="info" style="text-align: center; opacity: 0.6; font-size: 0.85rem;">No active players</div>'; } else { display.innerHTML = activePlayers.map(([player, config]) => { let icon = 'üéµ'; if (config.type === 'drum') icon = 'ü•Å'; else if (config.type === 'bass') icon = 'üé∏'; else if (config.type === 'lead') icon = 'üéπ'; else if (config.type === 'pads') icon = 'üåä'; return `<div class="player-info"><div><span class="player-indicator"></span> ${icon} ${player.toUpperCase()}: ${config.type}</div> <button onclick="stopPlayer('${player}')" style="background:none; border:none; color:#ff4757; cursor:pointer;">√ó</button></div>`; }).join(''); } document.getElementById('activeCount').textContent = activePlayers.length; }
    function getNextPlayer(type) { let i = 1; while (musicState[`${type}${i}`]) i++; return `${type}${i}`; }
    function toggleHelpModal() { const modal = document.getElementById('helpModal'); modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex'; }
    function showCurrentState() { const summary = getMusicStateSummary(); addOutput('üß† Current AI Memory (State):', 'system'); addOutput(summary, 'info'); }
    function setAiButtonsLoading(isLoading) { document.getElementById('analyzeBtn').disabled = isLoading; document.getElementById('nameTrackBtn').disabled = isLoading; if (isLoading) { document.getElementById('analyzeBtn').textContent = 'üß† ‚ú® Analyzing...'; document.getElementById('nameTrackBtn').textContent = 'üè∑Ô∏è ‚ú® Generating...'; } else { document.getElementById('analyzeBtn').textContent = 'üß† ‚ú® Analyze Track'; document.getElementById('nameTrackBtn').textContent = 'üè∑Ô∏è ‚ú® Name My Track'; } }
    async function callGeminiTextAPI(systemPrompt, userQuery) { if (!apiKey) { addOutput('‚ùå Please configure your API key first.', 'error'); return null; } if (Object.keys(musicState).filter(p => musicState[p].status === 'playing').length === 0) { addOutput('ü§î Your canvas is empty. Add music first!', 'warning'); return null; } setAiButtonsLoading(true); addOutput('‚ú® Calling the Gemini Co-pilot...', 'ai'); try { const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: userQuery }] }], systemInstruction: { parts: [{ text: systemPrompt }] } }) }); if (!response.ok) throw new Error(`API Error: ${response.status}`); const data = await response.json(); return data.candidates[0].content.parts[0].text; } catch (error) { addOutput(`‚ùå AI Co-pilot Error: ${error.message}`, 'error'); return null; } finally { setAiButtonsLoading(false); } }
    async function analyzeTrack() { const systemPrompt = "You are a friendly music theory professor. Analyze the provided musical data and give 3 concrete, inspiring suggestions for what the user could add next. Format with markdown bullet points."; const musicStateSummary = getMusicStateSummary(); const userQuery = `Analyze my track:\n\n${musicStateSummary}\n\nGive me a brief analysis and 3 suggestions.`; const result = await callGeminiTextAPI(systemPrompt, userQuery); if (result) { addOutput('--- AI Music Analysis ---', 'system'); result.split('\n').forEach(line => addOutput(line, 'ai')); addOutput('-------------------------', 'system'); } }
    async function nameMyTrack() { const systemPrompt = "You are a creative A&R scout. Your response MUST be a single, valid JSON object with 'title' and 'description' keys."; const musicStateSummary = getMusicStateSummary(); const userQuery = `Generate a track title and short description for this music:\n\n${musicStateSummary}`; const result = await callGeminiTextAPI(systemPrompt, userQuery); if (result) { try { const jsonMatch = result.match(/\{[\s\S]*\}/); if (!jsonMatch) throw new Error("No JSON found."); const parsed = JSON.parse(jsonMatch[0]); addOutput('--- AI Track Finalizer ---', 'system'); addOutput(`Title Suggestion: "${parsed.title}"`, 'success'); addOutput(`Description: ${parsed.description}`, 'info'); addOutput('-------------------------', 'system'); } catch (e) { addOutput('‚ùå AI returned an invalid format for the track name.', 'error'); console.error(e, "Raw response:", result); } } }
    function initVisualizer() { const container = document.getElementById('visualizerBars'); const barCount = 32; for (let i = 0; i < barCount; i++) container.appendChild(document.createElement('div')).className = 'viz-bar'; function update() { if (analyser) { const dataArray = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(dataArray); const bars = container.children; for (let i = 0; i < bars.length; i++) { const height = (dataArray[i * 2] / 255) * 100; bars[i].style.height = `${height}%`; } } requestAnimationFrame(update); } update(); }
    const presets = {
        'progressive-house': [
            {
                delay: 0, // √éncepe doar cu toba mare, pentru a stabili ritmul
                metadata: { type: 'kick', pattern: 'x---x---x---x---', amp: 0.95 }
            },
            {
                delay: 4000, // IntrƒÉ hi-hat-urile dupƒÉ 2 mƒÉsuri (la 120bpm)
                metadata: { type: 'hihats', pattern: '-h-h-h-h-h-h-h-h', amp: 0.4 } // Volum redus, de texturƒÉ
            },
            {
                delay: 8000, // Basul intrƒÉ dupƒÉ 4 mƒÉsuri, complet√¢nd groove-ul
                metadata: { type: 'bass', preset: 'square-bass', notes: [0, 0, 7, 5], amp: 0.8, effects: { sidechain: true } } // Puternic, dar sub kick
            },
            {
                delay: 16000, // Pad-urile intrƒÉ pentru a crea atmosferƒÉ
                metadata: { type: 'pads', preset: 'sine-pad', notes: [0, 4, 7, 11], amp: 0.55, effects: { reverb: 'long' } } // √én spate, cre√¢nd spa»õiu
            },
            {
                delay: 24000, // Melodia principalƒÉ (Lead) intrƒÉ dupƒÉ 12 mƒÉsuri, ca un punct culminant
                metadata: {
                    type: 'lead',
                    preset: 'saw-lead',
                    notes: [12, 16, 19, 16, 14, 16, 12],
                    amp: 0.7, // Prezent, dar nu acoperƒÉ tot
                    effects: { "filter": { "type": "lowpass", "frequency": 1200, "q": 5 }, "lfo": { "target": "filter", "rate": 4, "amount": 600 } }
                }
            }
        ],
        'dark-techno': [
            {
                delay: 0,
                metadata: { type: 'kick', pattern: 'x-x-x-x-', amp: 1.0, effects: { sidechain: true } } // Foarte puternic, specific genului
            },
            {
                delay: 2000, // Un clap percusiv
                metadata: { type: 'clap', pattern: '----c-------c---', amp: 0.7 }
            },
            {
                delay: 4000,
                metadata: {
                    type: 'bass',
                    preset: 'square-bass',
                    notes: [0, 0, 1, 0], // O linie de bas mai √ÆntunecatƒÉ, monotonƒÉ
                    amp: 0.85,
                    effects: { sidechain: true, saturation: 0.4 }
                }
            },
            {
                delay: 12000,
                metadata: {
                    type: 'hihats',
                    pattern: '--h-h-h-h-h',
                    amp: 0.5
                }
            }
        ],
        'future-bass': [
            {
                delay: 0,
                metadata: { type: 'kick', pattern: 'x---x---', amp: 0.85 }
            },
            {
                delay: 4000,
                metadata: { type: 'snare', pattern: '----o---', amp: 0.8 }
            },
            {
                delay: 8000,
                metadata: {
                    type: 'bass',
                    preset: 'saw-lead',
                    notes: [0, 7, 12, 7],
                    amp: 0.75,
                    effects: { lfo: { target: 'filter', rate: 3, amount: 400 } }
                }
            },
            {
                delay: 16000,
                metadata: {
                    type: 'pads',
                    preset: 'sine-pad',
                    notes: [0, 4, 7, 14],
                    amp: 0.6,
                    effects: { reverb: 'long', filter: { type: 'lowpass', frequency: 3000, q: 1.5 } }
                }
            },
            {
                delay: 24000,
                metadata: {
                    type: 'lead',
                    preset: 'saw-lead',
                    notes: [12, 19, 24, 19, 16],
                    amp: 0.65,
                    effects: { filter: { type: 'lowpass', frequency: 2500, q: 4 } }
                }
            }
        ],
        'minimal-deep': [
            {
                delay: 0,
                metadata: { type: 'kick', pattern: 'x-----x-', amp: 0.9 }
            },
            {
                delay: 8000,
                metadata: { type: 'hihats', pattern: '--h---h-', amp: 0.3 }
            },
            {
                delay: 16000,
                metadata: {
                    type: 'bass',
                    preset: 'square-bass',
                    notes: [0, 0, 0, 5],
                    amp: 0.65,
                    effects: { sidechain: true, filter: { type: 'lowpass', frequency: 400, q: 2 } }
                }
            },
            {
                delay: 32000,
                metadata: {
                    type: 'pads',
                    preset: 'sine-pad',
                    notes: [0, 7, 12],
                    amp: 0.4,
                    effects: { reverb: 'long' }
                }
            }
        ],
        'euphoric-trance': [
            {
                delay: 0,
                metadata: { type: 'kick', pattern: 'x-x-x-x-', amp: 0.95 }
            },
            {
                delay: 2000,
                metadata: { type: 'snare', pattern: '----o---', amp: 0.75 }
            },
            {
                delay: 4000,
                metadata: {
                    type: 'bass',
                    preset: 'square-bass',
                    notes: [0, 5, 7, 12],
                    amp: 0.8,
                    effects: { sidechain: true }
                }
            },
            {
                delay: 8000,
                metadata: {
                    type: 'pads',
                    preset: 'sine-pad',
                    notes: [0, 4, 7, 11],
                    amp: 0.6,
                    effects: { reverb: 'long' }
                }
            },
            {
                delay: 16000,
                metadata: {
                    type: 'lead',
                    preset: 'saw-lead',
                    notes: [12, 16, 19, 24, 19, 16],
                    amp: 0.7,
                    effects: { filter: { type: 'lowpass', frequency: 2000, q: 3 }, lfo: { target: 'filter', rate: 2, amount: 300 } }
                }
            }
        ],
        'ambient-cinematic': [
            {
                delay: 0,
                metadata: {
                    type: 'pads',
                    preset: 'sine-pad',
                    notes: [0, 4, 7, 11, 14],
                    amp: 0.45,
                    effects: { reverb: 'long', filter: { type: 'lowpass', frequency: 2000, q: 1 } }
                }
            },
            {
                delay: 12000,
                metadata: {
                    type: 'pads',
                    preset: 'sine-pad',
                    notes: [7, 11, 14, 19],
                    amp: 0.35,
                    effects: { delay: true, reverb: 'long', pan: 0.3 }
                }
            },
            {
                delay: 24000,
                metadata: {
                    type: 'bass',
                    preset: 'sine-pad',
                    notes: [0, 0, 0, 0],
                    amp: 0.25,
                    effects: { filter: { type: 'lowpass', frequency: 150, q: 1 } }
                }
            },
            {
                delay: 36000,
                metadata: {
                    type: 'lead',
                    preset: 'sine-pad',
                    notes: [24, 26, 28, 31],
                    amp: 0.4,
                    effects: { reverb: 'long', delay: true, pan: -0.4 }
                }
            }
        ]
    };
    async function loadPreset(presetName) {
        if (!presets[presetName]) return;
        if (!await ensureAudioContext()) return;
        stopAllSounds();
        addOutput(`üéº Loading ${presetName.toUpperCase()} preset...`, 'system');
        
        for (const layer of presets[presetName]) {
            // Use the new delay property!
            setTimeout(() => {
                const metadata = layer.metadata;
                if (metadata) {
                    // We no longer need to generate a command, we can just execute the metadata
                    const player = getNextPlayer(metadata.type.charAt(0));
                    metadata.player = player; // Assign a player name
                    
                    addOutput(`‚úÖ Loading preset layer: ${metadata.type} on ${player.toUpperCase()}`, 'system');
                    startBulletproofPlayer(player, metadata);
                    updateMusicState(player, metadata);
                }
            }, layer.delay); // Use the delay from the preset object
        }
    }
    function shareProject() { alert('Project sharing feature coming soon!'); }
    function toggleFullscreen() { try { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { addOutput(`‚ö†Ô∏è Fullscreen error: ${err.message}`, 'warning'); }); } else { document.exitFullscreen(); } } catch (error) { console.error("Fullscreen error:", error); addOutput('‚ö†Ô∏è Fullscreen not permitted.', 'warning'); } }
    function updateTimeDisplay() { const elapsed = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsed / 60); const seconds = elapsed % 60; document.getElementById('timeDisplay').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
    // --- IMPROVED APP LIFECYCLE MANAGEMENT ---
    function cleanupAudio() {
        try {
            console.log('üßπ Cleaning up audio resources...');
            scheduler.cancelAll();
            if (audioInitialized && oscillatorPool) {
                oscillatorPool.destroy(); // Use the new destroy method
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
            }
            musicState = {};
            activePlayers = {};
            audioInitialized = false;
            addOutput('üßπ Audio cleanup completed.', 'system');
        } catch (error) {
            console.error('Error during audio cleanup:', error);
        }
    }

    function handleAppClose() {
        cleanupAudio();
        console.log('üõë App closing gracefully');
    }

    // Enhanced visibility change handler for better resource management
    function handleVisibilityChange() {
        if (document.hidden) {
            // Page is hidden - pause audio processing
            if (audioContext && audioContext.state === 'running') {
                audioContext.suspend();
                addOutput('‚è∏Ô∏è Audio suspended (page hidden)', 'info');
            }
        } else {
            // Page is visible again - resume audio processing
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
                addOutput('‚ñ∂Ô∏è Audio resumed (page visible)', 'info');
            }
        }
    }

    // Backend connectivity checking
    async function checkBackendStatus() {
        try {
            const response = await fetch('http://localhost:5001/health', {
                method: 'GET',
                timeout: 3000
            });
            if (response.ok) {
                const data = await response.json();
                document.getElementById('backendStatusText').textContent = 'üü¢ FoxDot Backend';
                addOutput('üéµ FoxDot backend connected! Enhanced AI features available.', 'success');
                return true;
            }
        } catch (error) {
            document.getElementById('backendStatusText').textContent = 'üü° Direct API';
            addOutput('üîÑ Using direct API mode (FoxDot backend not available)', 'info');
        }
        return false;
    }

    window.addEventListener('load', () => {
        detectMobileDevice();
        setInterval(updateTimeDisplay, 1000);

        // Check backend connectivity
        checkBackendStatus();

        // Enhanced startup messages
        addOutput('üéµ Evolution Audio Engine v6.3 (AImCo_evo2) - Ready for Launch!', 'system');
        addOutput('üß† Advanced AI Music Intelligence ‚Ä¢ Rich Metadata ‚Ä¢ Live Effects', 'system');
        addOutput('üéõÔ∏è Features: Volume Control ‚Ä¢ Sidechain ‚Ä¢ Filters ‚Ä¢ LFO Modulation', 'ai');
        addOutput('üéº Enhanced Presets: Progressive House ‚Ä¢ Dark Techno ‚Ä¢ Future Bass', 'ai');
        addOutput('üöÄ Click "Enable Professional Audio" to begin creating!', 'warning');

        // Performance info
        const cores = navigator.hardwareConcurrency || 'unknown';
        const memory = navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'unknown';
        addOutput(`üíª System: ${cores} cores ‚Ä¢ ${memory} RAM ‚Ä¢ Max oscillators: ${maxConcurrentOscillators}`, 'info');
    });

    // Add proper event listeners for cleanup
    window.addEventListener('beforeunload', handleAppClose);
    window.addEventListener('unload', handleAppClose);
    window.addEventListener('visibilitychange', handleVisibilityChange);
    document.addEventListener('visibilitychange', handleVisibilityChange);

    document.getElementById('commandInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') processCommand(); });
</script>
</body>
</html>